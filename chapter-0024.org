# -*- eval: (org-babel-lob-ingest "./ob-haskell-common.org"); -*-

#+TITLE: Parser Combinators

#+PROPERTY: header-args:haskell :results replace output
#+PROPERTY: header-args:haskell+ :noweb yes
#+PROPERTY: header-args:haskell+ :wrap EXAMPLE

* 24.1 Parser Combinators
Given a serialized input in the form of sequence of bytes and return a
structured data type, normally a tree (AST: Abstract Syntax Tree).

* 24.2 A Few More Words of Introduction
This chapter will not proceed, like the others, bottom up because it
will be too much for a topic so big but the focus will be on enabling
the use of preexisting Haskell's libraries.

* 24.3 Understating the Parsing Process
A /Parser Combinator/ is an higher-order function that takes parsers
and returns a parser that is a combination of some sorts of the
parsers taken as input.

Parsers "consumes" the input text by "reading" one character at time.

The "effect" of parsers is our case is to "consume" input.

The "state" of the parser is the remaining input and the partial
result.

#+NAME: parser-prelude
#+BEGIN_SRC haskell :eval never
import Text.Trifecta
import Text.Parser.Combinators

:{
testParse :: Show a => String -> Parser a -> IO ()
testParse s p = print $ parseString p mempty s
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parser-prelude>>

:{
stop :: Parser a
stop = unexpected "stop"
:}

:{
one :: Parser Char
one = char '1'
:}

:{
oneTwo :: Parser Char
oneTwo = char '1' >> char '2'
:}

-- one >> stop

-- We are discarding the result of ~one~ but the effect of consuming
-- input remainins as expected from the monadic operator ~>>~

testParse "123" one
testParse "123" $ one >> stop
testParse "123" $ oneTwo >> stop
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success '1'
Failure (ErrInfo {_errDoc = (interactive):1:2: error: unexpected stop
1 | 123<EOF>
  |  ^       , _errDeltas = [Columns 1 1]})
Failure (ErrInfo {_errDoc = (interactive):1:3: error: unexpected stop
1 | 123<EOF>
  |   ^      , _errDeltas = [Columns 2 2]})
#+END_EXAMPLE

** Exercises: Parsing Practice

1. There's a combinator that expect an input stream to be finished at
   a particular point ~eof~ in ~Text.Parser.Combinators~, can you make
   ~one~ and ~oneTwo~ parsers fail because they don't exhaust the
   input stream?

   #+BEGIN_SRC haskell
   <<parser-prelude>>

   :{
   one :: Parser Char
   one = char '1'
   :}

   :{
   oneTwo :: Parser Char
   oneTwo = char '1' >> char '2'
   :}

   testParse "123" one
   testParse "123" oneTwo
   testParse "123" $ one >> eof
   testParse "123" $ oneTwo >> eof
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Success '1'
   Success '2'
   Failure (ErrInfo {_errDoc = (interactive):1:2: error: expected: end of input
   1 | 123<EOF>
     |  ^       , _errDeltas = [Columns 1 1]})
   Failure (ErrInfo {_errDoc = (interactive):1:3: error: expected: end of input
   1 | 123<EOF>
     |   ^      , _errDeltas = [Columns 2 2]})
   #+END_EXAMPLE

2. Use ~string~ to make a ~Parser~ that parses "1", "12" and "123"

   #+BEGIN_SRC haskell
   <<parser-prelude>>

   :{
   stop :: Parser a
   stop = unexpected "stop"
   :}

   :{
   p123 :: Parser String
   p123 = choice [string "123", string "12", string "1"]
   :}

   testParse "1" p123
   testParse "12" p123
   testParse "123" p123

   testParse "1" $ p123 >> stop
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Success "1"
   Success "12"
   Success "123"
   Failure (ErrInfo {_errDoc = (interactive):1:2: error: unexpected stop
   1 | 1<EOF>
     |  ^     , _errDeltas = [Columns 1 1]})
   #+END_EXAMPLE

3. Try writing a parser that behaves like ~string~ using ~char~

   #+BEGIN_SRC haskell
   <<parser-prelude>>

   :{
   string' :: String -> Parser String
   string' = traverse char
   :}

   testParse "123" $ string "123"
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Success "123"
   #+END_EXAMPLE

* 24.4 Parsing Fractions
#+NAME: parse-fraction
#+BEGIN_SRC haskell
<<parser-prelude>>

import Data.Ratio ((%))
import Text.Trifecta

:{
parseFraction :: Parser Rational
parseFraction = do
  numerator <- decimal
  char '/'
  denominator <- decimal
  if denominator == 0
  then fail "denominator cannot be zero"
  else return (numerator % denominator)
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parse-fraction>>

testParse "1/2" parseFraction
testParse "2/1" parseFraction
testParse "1/0" parseFraction
testParse "10" parseFraction
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success (1 % 2)
Success (2 % 1)
Failure (ErrInfo {_errDoc = (interactive):1:4: error: denominator cannot be zero, expected: digit
1 | 1/0<EOF>
  |    ^     , _errDeltas = [Columns 3 3]})
Failure (ErrInfo {_errDoc = (interactive):1:3: error: unexpected EOF, expected: "/", digit
1 | 10<EOF>
  |   ^     , _errDeltas = [Columns 2 2]})
#+END_EXAMPLE

First time that we see and use ~fail~

#+BEGIN_SRC haskell
-- What is this sorcery?
:t fail
:i fail
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
fail :: MonadFail m => String -> m a
class Monad m => MonadFail (m :: * -> *) where
  fail :: String -> m a
  	-- Defined in ‘Control.Monad.Fail’
#+END_EXAMPLE

** Exercise: Unit of Success
Write a parser ~onlyInteger~ that will parse a number, returns that
number and asserts that the input stops there (NOTE: ~integer >> eof~
works but the result is going to be, in case of success, always of
type ~()~, you must fix this)

#+BEGIN_SRC haskell
<<parser-prelude>>

:{
onlyInteger :: Parser Integer
onlyInteger = integer <* eof
:}

testParse "123" onlyInteger
testParse "123abc" onlyInteger
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success 123
Failure (ErrInfo {_errDoc = (interactive):1:4: error: expected: digit, end of input
1 | 123abc<EOF>
  |    ^        , _errDeltas = [Columns 3 3]})
#+END_EXAMPLE

* 24.5 Haskell's parsing ecosystem
...

* 24.6 Alternative
#+BEGIN_SRC haskell
import Control.Applicative

:i Alternative
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
class Applicative f => Alternative (f :: * -> *) where
  empty :: f a
  (<|>) :: f a -> f a -> f a
  some :: f a -> f [a]
  many :: f a -> f [a]
  {-# MINIMAL empty, (<|>) #-}
  	-- Defined in ‘GHC.Base’
instance Alternative ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.MonadPlus m => Alternative (WrappedMonad m)
  -- Defined in ‘Control.Applicative’
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
         Alternative (WrappedArrow a b)
  -- Defined in ‘Control.Applicative’
instance Alternative Result -- Defined in ‘Text.Trifecta.Result’
instance Alternative m => Alternative (Unspaced m)
  -- Defined in ‘Text.Parser.Token’
instance Alternative m => Alternative (Unlined m)
  -- Defined in ‘Text.Parser.Token’
instance Alternative m => Alternative (Unhighlighted m)
  -- Defined in ‘Text.Parser.Token’
instance Alternative Parser -- Defined in ‘Text.Trifecta.Parser’
instance [safe] Control.Monad.Trans.Error.Error e =>
                Alternative (Either e)
  -- Defined in ‘Control.Monad.Trans.Error’
instance Alternative [] -- Defined in ‘GHC.Base’
instance Alternative Maybe -- Defined in ‘GHC.Base’
instance Alternative IO -- Defined in ‘GHC.Base’
#+END_EXAMPLE

** Exercise: Try ~try~
Make a parser, using the existing ~parseFraction~ plus a new
~parseDecimal~ that can parse either decimals or fractions.

#+BEGIN_SRC haskell
<<parse-fraction>>

:{
parseDecimal :: Parser Integer
parseDecimal = decimal
:}

:{
parseNumber :: Parser (Either Rational Integer)
parseNumber = (Left <$> try parseFraction) <|> (Right <$> parseDecimal)
:}

testParse "1/10" parseNumber
testParse "10" parseNumber
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success (Left (1 % 10))
Success (Right 10)
#+END_EXAMPLE

* 24.7 Parsing Configuration Files
For the next few examples we will use INI files

#+BEGIN_SRC example
; comment
[section]
host=wikipedia.org
alias=claw
#+END_SRC

#+NAME: ini-prelude
#+BEGIN_SRC haskell :eval never
import Text.Trifecta
import Text.Parser.Combinators
import qualified Data.Map as M

:{
skipEOL :: Parser ()
skipEOL = skipMany (oneOf "\n")
:}
#+END_SRC

#+NAME: ini-parse-header
#+BEGIN_SRC haskell :results silent
<<ini-prelude>>

newtype Header = Header String deriving (Eq, Ord, Show)

:{
parseBetweenSquareBraket :: Parser a -> Parser a
parseBetweenSquareBraket p = char '[' *> p <* char ']'
:}

:{
parseHeader :: Parser Header
parseHeader = parseBetweenSquareBraket $ Header <$> some letter
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parser-prelude>>
<<ini-parse-header>>

testParse "[hello]" parseHeader
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success (Header "hello")
#+END_EXAMPLE

#+NAME: ini-parse-assignments
#+BEGIN_SRC haskell :results silent
<<ini-prelude>>

type Name = String
type Value = String

:{
parseAssignment :: Parser (Name, Value)
parseAssignment = do
  name <- some letter
  char '='
  value <- some (noneOf "\n")
  skipEOL
  return (name, value)
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parser-prelude>>
<<ini-prelude>>

testParse "foo=bar" parseAssignment
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success ("foo","bar")
#+END_EXAMPLE

#+NAME: ini-parse-section
#+BEGIN_SRC haskell :results silent
<<ini-prelude>>
<<ini-parse-header>>

type Assignments = M.Map Name Value

:{
skipComment :: Parser ()
skipComment = skipSome (oneOf ";#") >> skipMany (noneOf "\n") >> skipEOL
:}

:{
skipWhitespace :: Parser ()
skipWhitespace = () <$ oneOf " \n"
:}

:{
parseSection :: Parser (Header, Assignments)
parseSection = do
  many skipWhitespace
  many skipComment
  header <- parseHeader
  skipEOL
  assignments <- some parseAssignment
  return (header, M.fromList assignments)
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parser-prelude>>
<<ini-parse-section>>

testParse ";ignore" skipComment
testParse ";ignore\n" skipComment
testParse ";ignore\n#blabla\n" (some skipComment)
testParse ";ignore\n#blabla\n" (many skipComment)
testParse ";ignore\n[foo]\nbar=baz" parseSection
testParse ";ignore\n\n[foo]\nbar=baz\n" parseSection
testParse ";ignore\n\n[foo]\nbar=baz\n\nbiz=fooz" parseSection
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success ()
Success ()
Success [(),()]
Success [(),()]
Success (Header "foo",fromList [("bar","baz")])
Success (Header "foo",fromList [("bar","baz")])
Success (Header "foo",fromList [("bar","baz"),("biz","fooz")])
#+END_EXAMPLE

#+NAME: ini-parse
#+BEGIN_SRC haskell :results silent
<<ini-parse-section>>

newtype Config = Config (M.Map Header Assignments) deriving (Eq, Show)

:{
parseIni :: Parser Config
parseIni = do
  sections <- some parseSection
  return $ Config (M.fromList sections)
:}
#+END_SRC

#+BEGIN_SRC haskell
<<parser-prelude>>
<<ini-parse>>

testParse ";ignore\n\n[foo]\nfor=foz\n\n#ignore\n[bar]\nbaz=biz" parseIni
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success (Config (fromList [(Header "bar",fromList [("baz","biz")]),(Header "foo",fromList [("for","foz")])]))
#+END_EXAMPLE

* 24.8 Character and token parsers
Tokenization is about ignoring noise in the finer grained parser so
that the higher level parsers can be simpler. In parser combinators
~token~ can also be found as ~lex~ that stands for /lexeme/ aka "basic
lexical unit of a language".

#+BEGIN_SRC haskell
<<parser-prelude>>

testParse "aaa" $ char 'a'
testParse "aaa" $ some (char 'a')
testParse "a a a" $ some (char 'a')
testParse "a a a" $ some (token $ char 'a')
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Success 'a'
Success "aaa"
Success "a"
Success "aaa"
#+END_EXAMPLE

* 24.9 Polymorphic parsers
By defining parsers using ~TokenParsing~ from
~Text.Parser.Combinators~ we can use then multiple libraries to run
the parser (ex. /Trifecta/, /Attoparsec/, ...)

** Backtracking
Alternative do not backtrack, with this you can have errors that are
hard to debug

#+BEGIN_SRC haskell
<<parser-prelude>>

p = (char '1' >> char '2') <|> (char '1' >> char '3')
p' = try (char '1' >> char '2') <|> (char '1' >> char '3')

q = try (char '1' >> char '2' >> char '3') <|> char '3'
q' = try (char '3') <|> (char '1' >> char '2' >> char '3')

testParse "13" p -- fails but intuitively it shouldn't have
testParse "13" p' -- you must use try
testParse "124" q -- even then thouhg the error can be deceiving
testParse "124" q' -- when possible you should take care of "precedence"
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Failure (ErrInfo {_errDoc = (interactive):1:2: error: expected: "2"
1 | 13<EOF>
  |  ^      , _errDeltas = [Columns 1 1]})
Success '3'
Failure (ErrInfo {_errDoc = (interactive):1:1: error: expected: "3"
1 | 124<EOF>
  | ^        , _errDeltas = [Columns 0 0]})
Failure (ErrInfo {_errDoc = (interactive):1:3: error: expected: "3"
1 | 124<EOF>
  |   ^      , _errDeltas = [Columns 2 2]})
#+END_EXAMPLE

* 24.10 Marshalling from an AST to a datatype
...
