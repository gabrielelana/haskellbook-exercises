* 11.1 Algebraic datatypes

  #+BEGIN_QUOTE
  A type can be tought of as an enumeration of constructors that have
  zero or more arguments.
  #+END_QUOTE

  Expectations of current chapter:
  - explain the "algebra" of /algebraic datatype/
  - analyze the construction of data constructors
  - spell out when and how to write your own datatypes
  - clarify usage of /type synonyms/ and /newtypes/
  - introduce kinds

* 11.2 Data declaration review

  #+BEGIN_EXAMPLE
  data Bool  =  False  |  True
  [1]  [2]  [3] [4]   [5] [6]
  #+END_EXAMPLE

  1. What follows is a data declaration or a declaration of a
     /datatype/
  2. Name of the /type constructor/ with no arguments.
  3. Divides the /type constructor/ from its /data constructors/
  4. Data constructor with no arguments. Also called /nullary data
     constructor/. It's one of the possible values of this type.
  5. Denotes a /sum type/
  6. Data constructor with no arguments. Also called /nullary data
     constructor/. It's one of the value of this type.

  #+BEGIN_EXAMPLE
  data [] a = []  |  a : [a]
  [1]  [2]    [3]    [4]
  #+END_EXAMPLE

  1. What follows is a data declaration or a declaration of a
     /datatype/
  2. Type constructor with one argument. Here the argument is a
     polymorphic type variable so the list argument can be of
     different types.
  3. Data constructor of the empty list with no arguments.
  4. Data constructor of the not empty list with two arguments.

  #+BEGIN_QUOTE
  A type can be tought of as an enumeration of constructors that have
  zero or more arguments.
  #+END_QUOTE

  - When we talk about /data declaration/ we talk about the definition
    of the entire type.
  - ~Bool~ is an enumeration of two possible constructors each of
    which take zero arguments
  - ~[] a~ is an enumeration of two possible constructors one of the
    takes two arguments.
  - The pipe (~|~) denotes a /sum types/ aka a type with more than one
    data constructor.

* 11.3 Type and data constructors
  Two kind of constructors in Haskell:
  - Type constructor :: used at the type level, type signature,
       typeclass declarations and instances. Static and resolves at
       compile time.
  - Data constructor :: construct values used at term level, values
       with which we can interact at runtime.

  Why *constructors*? Because they define a means of creating or
  building types and values.

  Constructors that take no arguments are called /nullary
  constructors/ or /constants/. Ex. ~Bool~ is a /type constant/ and
  ~True~ and ~False~ are /constants/

  When a constructor takes an argument than it behaves like a function
  in the sense that must be /applied/ to become a /concrete type/ or a
  /value/

* 11.4 Type constructors and kinds

  #+BEGIN_SRC haskell :eval never
  data [] a = [] | a : [a]
  #+END_SRC

  This must be applied to a concrete type before we have a list.

  Kinds are the types of types, or types one level up. We represent
  kinds in Haskell with ~*~. We know something is a fully applied,
  concrete type when it is represented as ~*~. When it is ~* -> *~,
  it, like a function, is still waiting to be applied.

  #+BEGIN_SRC haskell :results output :wrap EXAMPLE :epilogue ":load"
  :k Bool
  :k [Int]
  :k []
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  Bool :: *
  [Int] :: *
  [] :: * -> *
  #+END_EXAMPLE

  ~Bool~ and ~[Int]~ are fully applied and therefore are /concrete
  types/. ~[]~ still needs to be applied to become a concrete type,
  this is what /constructor/ in "type constructor" stands for.

* 11.5 Data constructors and values

  #+BEGIN_SRC haskell :eval never
  data PugType = PugData
  --             [1]

  data HuskyType a = HuskyData
  --                 [2]

  data DogueDeBordeaux doge = DogueDeBordeaux doge
  --                          [3]
  #+END_SRC

  1. Data constructor ~PugData~ takes no arguments so is /nullary data
     contructor/ or a /constant value/
  2. Data constructor ~HuskyData~ does not use the declared type
     variable ~a~ this means that ~HuskyData~ is a /constat value/ and
     the type argument ~a~ is a /phantom/ or /has no witness/
  3. Data constructor ~DogueDeBordeaux~ shares the same name as its
     type constructor but they are not the same thing

  So the behavior of constructors is such that if they don’t take any
  arguments, they behave like (type or value-level) constants. If they
  do take arguments, they act like (type or value-level) functions
  that don’t do anything except get applied.

** Exercise: Dog Types
   Given the following data declaration

   #+BEGIN_SRC haskell :results none
   :{
   data Doggies a = Husky a
                  | Mastiff a
                  deriving (Eq, Show)
   :}
   data DogueDeBordeaux doge = DogueDeBordeaux doge
   #+END_SRC

   1. ~Doggies~ is a type constructor
   2. ~Doggies~ has kind ~Doggies :: * -> *~
   3. ~Doggies String~ has kind ~Doggies String :: *~
   4. ~Husky 10~ has type ~Husky 10 :: Num a => Doggies a~
   5. ~Husky (10 :: Integer)~ has type ~Husky (10 :: Integer) :: Doggies Integer~
   6. ~Mastiff "Scooby Doo"~ has type ~Mastiff "Scooby Doo" :: Doggies [Char]~
   7. ~DogueDeBordeaux~ is both a type and a data constructor
   8. ~DogueDeBordeaux~ has type ~DogueDeBordeaux :: doge -> DogueDeBordeaux doge~
   9. ~DogueDeBordeaux "doggie"~ has type ~DogueDeBordeaux "doggie" :: DogueDeBordeaux [Char]~

* 11.6 What's a type and what's data?
  - Type constructors -> Compile time
  - Data constructors -> Runtime
  - They both begins with a capital letter
  - In a /data declaration/ what comes before ~=~ is a type constructor
  - In a /data declaration/ what comes after ~=~ is a data constructor
  - Data constructors are usually generated by data declaration
  - Data constructors cannot be totally generated by data declarations
    when they take other types.

  #+BEGIN_SRC haskell :results none
  data Price = Price Integer deriving (Eq, Show)
  #+END_SRC

  Here ~Price~ doesn't depends only by the current datatype but also
  on ~Integer~

** Exercise: Vehicles

   #+NAME: vehicle
   #+BEGIN_SRC haskell :results none
   data Price = Price Integer deriving (Eq, Show)

   :{
   data Manufacturer = Mini
                     | Mazda
                     | Tata
                     deriving (Eq, Show)
   :}

   :{
   data Airline = PapuAir
                | CatapultsR'Us
                | TakeYourChancesUnited
                deriving (Eq, Show)
   :}

   :{
   data Vehicle = Car Manufacturer Price
                | Plane Airline
                deriving (Eq, Show)
   :}

   myCar = Car Mini (Price 14000)
   urCar = Car Mazda (Price 20000)
   clownCar = Car Tata (Price 7000)
   doge = Plane PapuAir
   #+END_SRC

   1. ~myCar~ type is ~myCar :: Vehicle~
   2. Define the following functions: ~isCar~, ~isPlane~, ~areCars~
      #+BEGIN_SRC haskell :results none :noweb yes :epilogue ":load"
      <<vehicle>>

      :{
      isCar :: Vehicle -> Bool
      isCar (Car _ _) = True
      isCar _ = False
      :}

      :{
      isPlane :: Vehicle -> Bool
      isPlane (Plane _) = True
      isPlane _ = False
      :}

      :{
      areCars :: [Vehicle] -> [Bool]
      areCars = map isCar
      :}

      isCar myCar
      isCar urCar
      isCar doge

      isPlane myCar
      isPlane doge

      areCars [myCar, urCar]
      areCars [myCar, doge]
      #+END_SRC
   3. Function to tell the manufacturer of a car
      #+BEGIN_SRC haskell :results none :noweb yes :epilogue ":load"
      <<vehicle>>

      :{
      manufacturer :: Vehicle -> Manufacturer
      manufacturer (Car m _) = m
      manufacturer _ = error "Not a car"
      :}

      manufacturer myCar
      manufacturer urCar
      manufacturer doge
      #+END_SRC
   4. If you use the previous function on a ~Plane~ data you get an
      error
   5. Change ~Plane~ to take also the size
      #+BEGIN_SRC haskell :results none
      data Price = Price Integer deriving (Eq, Show)

      data Size = Size Integer deriving (Eq, Show)

      data Manufacturer = Mini
                        | Mazda
                        | Tata
                        deriving (Eq, Show)

      data Airline = PapuAir
                   | CatapultsR'Us
                   | TakeYourChancesUnited
                   deriving (Eq, Show)

      data Vehicle = Car Manufacturer Price
                   | Plane Airline Size
                   deriving (Eq, Show)

      myCar = Car Mini (Price 14000)
      urCar = Car Mazda (Price 20000)
      clownCar = Car Tata (Price 7000)
      doge = Plane PapuAir (Size 1000)
      #+END_SRC

* 11.7 Data constructor arities

  #+BEGIN_QUOTE
  A type can be tought of as an enumeration of constructors that have
  zero or more arguments.
  #+END_QUOTE

  #+BEGIN_SRC haskell :results none
  -- nullary data constructor or costant
  data Example0 = Example0 deriving (Eq, Show)

  -- unary data constructor
  data Example1 = Example1 Int deriving (Eq, Show)

  -- product data constructor of Int and String
  data Example2 = Example2 Int String deriving (Eq, Show)
  #+END_SRC

* 11.8 What makes these datatypes algebraic?
  Algebraic datatypes in Haskell are algebraic because we can describe
  the patterns of argument structures using two basic operations: sum
  and product.

** Exercise: Cardinality

   1. Cardinality of the following? 1
      #+BEGIN_SRC haskell :results none
      data PugType = PugData
      #+END_SRC
   2. Cardinality of the following? 3
      #+BEGIN_SRC haskell :results none
      data Airline = PapuAir
                   | CatapultsR'Us
                   | TakeYourChancesUnited
      #+END_SRC
   3. Given that we know the cardinality of ~Int8~ what's the
      cardinality of ~Int16~? ~∥Int8∥ ^ 2~
   4. What can you say about the cardinality of ~Int~? That is limited
      because it has an instance of the ~Bounded~ typeclass. What can
      you say about the cardinality of ~Integer~? It's infinite.
   5. What’s the connection between the ~8~ in ~Int8~ and that type’s
      cardinality of ~256~? ~8~ is the amount of bits used to
      represents values of ~Int8~ type, therefore you can represent
      ~2^8~ or ~256~ possible values.

** Exercise: For Example
   #+BEGIN_SRC haskell :results none
   data Example = MakeExample deriving (Eq, Show)
   #+END_SRC

   1. The type of data constructor ~MakeExample~ is
      ~MakeExample :: Example~. What happens when you request the
      type of Example? You get an error because ~Example~ data
      constructor is not in scope
   2. Using ~:i Example~ you can tell that ~Example~ is type
      constructor, you get the data declaration and you can tell which
      are the typeclasses implemented
   3. Create an example of a unary data constructor
      #+BEGIN_SRC haskell :results none
      data AnotherExample = MakeAnotherExample Int deriving (Eq, Show)
      #+END_SRC
      The type is ~MakeAnotherExample :: Int -> AnotherExample~

* 11.9 Newtype
  - It only allows data constructor with one argument.
  - The cardinality is the cardinality of the type given as argument.
  - It only exists at compile time.
  - It has no runtime overhead.
  - It reuses the representation of the type it contains. The
    difference between newtype and the type it contains is gone by the
    time the compiler generates the code.
  - We can define typeclasses on newtypes but not on aliases.

  #+BEGIN_SRC haskell :results none :prologue ":{" :epilogue ":}"
  tooManyGoats :: Int -> Bool
  tooManyGoats n = n > 42
  #+END_SRC

  The problem is we can mix up the number of cows with the number of goats

  #+BEGIN_SRC haskell :results none
  tooManyGoats 10   -- number of goats
  tooManyGoats 100  -- number of cows
  #+END_SRC

  Solution

  #+BEGIN_SRC haskell :results none
  newtype Goats = Goats Int deriving (Eq, Show)
  newtype Cows = Cows Int deriving (Eq, Show)
  #+END_SRC

  Then

  #+BEGIN_SRC haskell :results none :prologue ":{" :epilogue ":}"
  tooManyGoats' :: Goats -> Bool
  tooManyGoats' (Goats n) = n > 42
  #+END_SRC

  This works

  #+BEGIN_SRC haskell :results none
  tooManyGoats' (Goats 10)
  #+END_SRC

  This doesn't compile

  #+BEGIN_SRC haskell :results none
  tooManyGoats' (Cows 43)
  #+END_SRC

  We can define a /typeclass/ for a /newtype/

  #+BEGIN_SRC haskell :results none
  class TooMany a where tooMany :: a -> Bool

  instance TooMany Int where tooMany n = n > 42

  tooMany (11 :: Int)
  tooMany (43 :: Int)

  instance TooMany Goats where tooMany (Goats n) = n > 43

  tooMany (Goats 11)
  tooMany (Goats 43)

  :t tooMany
  #+END_SRC

  Since /newtypes/ are thin wrappers around a preexisting type for
  /newtypes/ we can derive the /typeclasses/ implementations of the
  wrapped type with a language extension called
  ~GeneralizedNewtypeDeriving~

  #+BEGIN_SRC haskell :results none
  {-# LANGUAGE GeneralizedNewtypeDeriving #-}

  class TooMany a where tooMany :: a -> Bool

  instance TooMany Int where tooMany n = n > 42

  newtype Goats = Goats Int deriving (Eq, Show, TooMany)

  tooMany (Goats 11)
  tooMany (Goats 43)
  #+END_SRC

** Exercise: Logic Goats

   1. Write an instance of typeclass ~TooMany~ for ~(Int, String)~

      #+BEGIN_SRC haskell :results none
      {-# LANGUAGE FlexibleInstances #-}

      instance TooMany (Int, String) where tooMany (n, _) = n > 42

      tooMany (11 :: Int, "Hello Mike")
      #+END_SRC

   2. Write an instance of typeclass ~TooMany~ for ~(Int, Int)~
      summing the values together.

      #+BEGIN_SRC haskell :results none
      {-# LANGUAGE FlexibleInstances #-}

      instance TooMany (Int, Int) where tooMany (n, m) = (n + m) > 42

      tooMany (5 :: Int, 6 :: Int)
      tooMany (5 :: Int, 40 :: Int)
      #+END_SRC

   3. Write an instance of typeclass ~TooMany~ for ~(Num a, TooMany a)~

      #+BEGIN_SRC haskell :results none
      {-# LANGUAGE FlexibleInstances #-}

      instance TooMany Int where tooMany n = n > 42

      instance (Num a, TooMany a) => TooMany (a, a) where tooMany (n, m) = tooMany (n + m)

      tooMany (50 :: Int, 10 :: Int)
      #+END_SRC

* 11.10 Sum Types
  - The ~|~ represents the /disjunction/ that is "/or/".
  - The cardinality of a sum type is the sum of the cardinality of
    its inhabitants.

** Exercise: Pity the Bool

   1. Given a datatype
      #+BEGIN_SRC haskell :results none
      data BigSmall
        = Big Bool
        | Small Bool
        deriving (Eq, Show)
      #+END_SRC

      What's the cardinality of this datatype? 4

      #+BEGIN_EXAMPLE
      Big Bool | Small Bool = ??
      Big (True | False) | Small (True | False) = ??
      Big (True + False) | Small (True + False) = ??
      Big (1 + 1) | Small (1 + 1) = ??
      Big 2 | Small 2 = ??
      2 | 2 = ??
      2 + 2 = 4
      #+END_EXAMPLE

   2. Given a datatype
      #+BEGIN_SRC haskell :results none :prologue ":{" :epilogue ":}"
      import Data.Int -- bring Int8 in scope

      data NumberOrBool
        = Numba Int8
        | BoolyBool Bool
        deriving (Eq, Show)
      #+END_SRC

      1. What is the cardinality of ~NumberOrBool~? 258
      2. What happens if you try to create a Numba with a numeric
         literal larger than 127? Error. And with a numeric literal
         smaller than (-128)? Error.

* 11.11 Product Types
  - The cardinality of a product type is the product of the
    cardinality of its inhabitants.
  - Product types express /conjunction/ that is "/and/".
  - Any data constructor with two or more type arguments it's a
    product.
  - Product types do not have speciali syntax like ~|~ for sum types.

** Record Syntax

   The following solution to represent a person
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   data Person = Person String Int deriving (Eq, Show)

   jm = Person "Julie" 27
   rk = Person "Rick" 42

   :{
   name :: Person -> String
   name (Person n _) = n
   :}

   :t name
   name jm
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   name :: Person -> String
   Julie
   #+END_EXAMPLE

   Can be replaced with a record syntax, a function for each field
   (in this case ~name~ and ~age~) will be implicitly defined
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   data Person = Person {name :: String, age :: Int} deriving (Eq, Show)

   jm = Person "Julie" 27
   rk = Person "Rick" 42

   :t name
   :t age

   name jm
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   name :: Person -> String
   age :: Person -> Int
   Julie
   #+END_EXAMPLE

* 11.12 Normal Form
  As in normal arithmetic multiplication distributes over addition
  #+BEGIN_EXAMPLE
  a * (b + c) = (a * b) + (a * c)
  #+END_EXAMPLE

  In haskell product types distributes over sum types. The sum of the
  product types is called the /normal form/

  ~Author~ it is a product of a sum type
  #+BEGIN_SRC haskell :results none :epilogue ":load"
  data Fiction = Fiction deriving Show
  data NonFiction = NonFiction deriving Show

  :{
  data BookType = FictionBook Fiction
                | NonFictionBook NonFiction
                deriving Show
  :}

  type AuthorName = String

  data Author = Author (AuthorName, BookType) deriving Show
  #+END_SRC

  In normal form it will become like that
  #+BEGIN_SRC haskell :results none :epilogue ":load"
  type AuthorName = String
  data Author = Fiction AuthorName
              | NonFiction AuthorName
              deriving (Eq, Show)
  #+END_SRC

** Exercises: How Does Your Garden Grow?

   1. Given the type
      #+BEGIN_SRC haskell :results none :epilogue ":load"
      :{
      data FlowerType = Gardenia
                      | Daisy
                      | Rose
                      | Lilac
                      deriving Show
      :}

      type Gardener = String

      data Garden = Garden Gardener FlowerType deriving Show
      #+END_SRC

      What is the normal form of Garden?
      #+BEGIN_SRC haskell :results none :epilogue ":load"
      type Gardener = String

      :{
      data Garden = Gardenia Gardener
                  | Daisy Gardener
                  | Rose Gardener
                  | Lilac Gardener
                  deriving Show
      :}
      #+END_SRC

* 11.13 Constructing and Deconstructiong Values

   See how ~Sum~ and ~Product~ can generalise sum and product types
   #+BEGIN_SRC haskell :results none
   data Sum a b = First a | Second b deriving (Eq, Show)
   data Product a b = Product a b deriving (Eq, Show)
   #+END_SRC

   How to use them
   #+BEGIN_SRC haskell :results none
   data Twitter = Twitter deriving (Eq, Show)
   data Reddit = Reddit deriving (Eq, Show)
   type SocialNetwork = Sum Twitter Reddit
   #+END_SRC

   How to construct values
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   First Twitter :: SocialNetwork
   Second Reddit :: SocialNetwork

   -- the following are not valid
   First Reddit :: SocialNetwork
   Second Twitter :: SocialNetwork
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   First Twitter
   Second Reddit
   <interactive>:328:1: error:
       • Couldn't match type ‘Reddit’ with ‘Twitter’
         Expected type: SocialNetwork
           Actual type: Sum Reddit Reddit
       • In the expression: First Reddit :: SocialNetwork
         In an equation for ‘it’: it = First Reddit :: SocialNetwork
   <interactive>:329:1: error:
       • Couldn't match type ‘Twitter’ with ‘Reddit’
         Expected type: SocialNetwork
           Actual type: Sum Twitter Twitter
       • In the expression: Second Twitter :: SocialNetwork
         In an equation for ‘it’: it = Second Twitter :: SocialNetwork
   #+END_EXAMPLE

   Type aliases will let to create what you will consider the wrong
   types
   #+BEGIN_SRC haskell :results none
   data Sum a b = First a | Second b deriving (Eq, Show)
   type Twitter = String
   type Reddit = String
   type SocialNetwork = Sum Twitter Reddit

   First "Twitter" :: SocialNetwork
   Second "Reddit" :: SocialNetwork

   First "Reddit" :: SocialNetwork
   Second "Twitter" :: SocialNetwork
   #+END_SRC

   Accidental bottoms in records
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   data Car = Null | Car {model :: String , year :: Integer}

   :t model
   :t Null

   -- So the type system will let us do this
   model Null
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   model :: Car -> String
   Null :: Car
   "*** Exception: No match in record selector model
   #+END_EXAMPLE

   Avoid accidental bottoms in records
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   data Car = Car {model :: String, year :: Integer} deriving (Eq, Show)
   data Automobile = Null | Automobile Car

   boxter = Car {model = "Porche Boxter", year = 2016}
   :t model
   model boxter
   model Null
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   model :: Car -> String
   Porche Boxter
   <interactive>:771:7: error:
       • Couldn't match expected type ‘Car’ with actual type ‘Automobile’
       • In the first argument of ‘model’, namely ‘Null’
         In the expression: model Null
         In an equation for ‘it’: it = model Null
   #+END_EXAMPLE

** Exercises: Programmers
   Given the types
   #+BEGIN_SRC haskell :results none
   :{
   data OperatingSystem = GnuPlusLinux
                        | OpenBSD
                        | Mac
                        | Windows
                        deriving (Eq, Show)
   :}

   :{
   data ProgrammingLanguage = Haskell
                            | Agda
                            | Idris
                            | PureScript
                            deriving (Eq, Show)
   :}

   :{
   data Programmer = Programmer { lang :: ProgrammingLanguage
                                , os :: OperatingSystem
                                }
                     deriving (Eq, Show)
   :}
   #+END_SRC

   Write a function that generates all possible values of
   ~Programmer~. Use the provided lists of inhabitants of
   ~OperatingSystem~ and ~ProgrammingLanguages~.
   #+BEGIN_SRC haskell :results output :wrap EXAMPLE :post ghci-clean(content=*this*) :epilogue ":load"
   :{
   allOperatingSystems :: [OperatingSystem]
   allOperatingSystems = [ GnuPlusLinux
                         , OpenBSD
                         , Mac
                         , Windows
                         ]
   :}

   :{
   allProgrammingLanguages :: [ProgrammingLanguage]
   allProgrammingLanguages = [ Haskell
                             , Agda
                             , Idris
                             , PureScript
                             ]
   :}

   :{
   allProgrammers :: [Programmer]
   allProgrammers = [ Programmer { os = os, lang = lang } | os <- allOperatingSystems, lang <- allProgrammingLanguages ]
   :}

   allProgrammers
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   [Programmer {lang = Haskell, os = GnuPlusLinux},
    Programmer {lang = Agda, os = GnuPlusLinux},
    Programmer {lang = Idris, os = GnuPlusLinux},
    Programmer {lang = PureScript, os = GnuPlusLinux},
    Programmer {lang = Haskell, os = OpenBSD},
    Programmer {lang = Agda, os = OpenBSD},
    Programmer {lang = Idris, os = OpenBSD},
    Programmer {lang = PureScript, os = OpenBSD},
    Programmer {lang = Haskell, os = Mac},
    Programmer {lang = Agda, os = Mac},
    Programmer {lang = Idris, os = Mac},
    Programmer {lang = PureScript, os = Mac},
    Programmer {lang = Haskell, os = Windows},
    Programmer {lang = Agda, os = Windows},
    Programmer {lang = Idris, os = Windows},
    Programmer {lang = PureScript, os = Windows}]
   #+END_EXAMPLE


* Exercises

  #+NAME: ghci-clean
  #+BEGIN_SRC emacs-lisp :var content="" :results raw
  (string-join
   (seq-filter
    (lambda (line)
      (not (string-empty-p line)))
    (seq-map
     (lambda (line)
       (replace-regexp-in-string "^.*Prelude[^>]*> " "" line))
     (split-string content "\n")))
   "\n"))
  #+END_SRC

  #+NAME: add-current-chapter-directory-in-path
  #+BEGIN_SRC emacs-lisp :output raw
   (concat
    ":set -i"
    (file-name-as-directory (file-name-directory (buffer-file-name)))
    (file-name-base (buffer-file-name)))
  #+END_SRC

  #+NAME: start-at-line
  #+BEGIN_SRC sh :var content="" :var line="0" :results raw
  echo "$content" | tail -n +$line
  #+END_SRC
