# -*- eval: (org-babel-lob-ingest "./ob-haskell-common.org"); -*-

#+TITLE: Monad Transformers

#+PROPERTY: header-args:haskell :results replace output
#+PROPERTY: header-args:haskell+ :noweb yes
#+PROPERTY: header-args:haskell+ :wrap EXAMPLE

* 26.01 Monad Transformers
...

* 26.02 MaybeT
#+NAME: MaybeT
#+BEGIN_SRC haskell :results silent
import Control.Applicative

newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

:{
instance Functor m => Functor (MaybeT m) where
  fmap f (MaybeT ma) = MaybeT $ (fmap . fmap) f ma
:}

:{
instance Applicative m => Applicative (MaybeT m) where
  pure = MaybeT . pure . pure

  (MaybeT mf) <*> (MaybeT ma) = MaybeT $ liftA2 (<*>) mf ma
:}
#+END_SRC

Note that we need to define ~Functor~ and ~Applicative~ instances for
~MaybeT~ but we don't need to do anything specific with ~Maybe~ aka
all ~Functor~ and ~Applicative~ instances of transformers will look
the same (XXX: is this true?).

Is with the ~Monad~ instance that things change.

#+NAME: MaybeT
#+BEGIN_SRC haskell :results silent
<<MaybeT>>

:{
instance Monad m => Monad (MaybeT m) where
  return = pure

  -- ma :: MaybeT m a
  -- f :: a -> MaybeT m b
  (MaybeT ma) >>= f = MaybeT $ do
    -- ma :: m (Maybe a)
    -- v :: Maybe a
    v <- ma
    case v of
      Nothing -> return Nothing
      Just a -> (runMaybeT . f) a
:}
#+END_SRC

* 26.3 EitherT
(XXX: why the order ~e m a~ for the type parameters and not ~m e a~?)

#+NAME: EitherT
#+BEGIN_SRC haskell :results silent
import Control.Applicative
import Data.Functor

:set -XLambdaCase

newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }

-- 1. Write the Functor instance for EitherT
:{
instance Functor m => Functor (EitherT e m) where
  fmap f (EitherT ma) = EitherT $ (fmap . fmap) f ma
:}

-- 2. Write the Applicative instance for EitherT
:{
instance Applicative m => Applicative (EitherT e m) where
  pure = EitherT . pure . pure

  (EitherT mf) <*> (EitherT ma) = EitherT $ liftA2 (<*>) mf ma
:}

-- 3. Write the Monad instance for EitherT
:{
instance Monad m => Monad (EitherT e m) where
  return = pure

  (EitherT ma) >>= f = EitherT $ do
    v <- ma
    case v of
      Left e -> return $ Left e
      Right a -> (runEitherT . f) a
:}

-- 4. Write the swapEitherT helper function for EitherT
:{
swapEitherT :: (Functor m) => EitherT e m a -> EitherT a m e
swapEitherT (EitherT ma) = EitherT $ ma <&> \case Left e -> Right e
                                                  Right a -> Left a
:}

-- 5. Write the transformer variant of either catamorphism
:{
eitherT :: (Monad m) => (a -> m c) -> (b -> m c) -> EitherT a m b -> m c
eitherT f g (EitherT ma) = ma >>= (either f g)
-- without either
-- eitherT f g (EitherT ma) = do
--   v <- ma
--   case v of
--     Left a -> f a
--     Right b -> g b
:}
#+END_SRC

* 26.4 ReaderT
#+NAME: ReaderT
#+BEGIN_SRC haskell :results silent
newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }

:{
instance Functor m => Functor (ReaderT r m) where
  fmap f (ReaderT fma) = ReaderT $ \r -> f <$> (fma r)
:}

:{
instance Applicative m => Applicative (ReaderT r m) where
  pure = ReaderT . const . pure

  (ReaderT fmf) <*> (ReaderT fma) = ReaderT $ \r -> (fmf r) <*> (fma r)
:}

:{
instance Monad m => Monad (ReaderT r m) where
  return = pure

  (ReaderT fma) >>= f = ReaderT $ \r -> fma r >>= flip (runReaderT . f) r
:}
#+END_SRC

* 26.5 StateT
#+NAME: StateT
#+BEGIN_SRC haskell :results silent
import Control.Applicative
import Data.Bifunctor

:set -XTupleSections

newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }

:{
instance Functor m => Functor (StateT s m) where
  fmap f (StateT sma) = StateT $ \s -> first f <$> sma s
:}

:{
instance Monad m => Applicative (StateT s m) where
  pure a = StateT $ pure . (,) a

  -- Wrong, without properly sequencing the state
  -- (StateT smf) <*> (StateT sma) =
  --   StateT $ \s -> ((first . fst) <$> (smf s)) <*> (sma s)

  -- Right, but I don't know why
  -- (StateT smf) <*> (StateT sma) = StateT $ do
  --   mf <- smf
  --   ma <- sma
  --   return $ (first . fst) <$> mf <*> ma

  (StateT smf) <*> (StateT sma) = StateT $ \s -> do
    (f, s') <- smf s
    (a, s'') <- sma s'
    return $ (f a, s'')
:}

:{
instance Monad m => Monad (StateT s m) where
  return = pure

  (StateT sma) >>= f = StateT $ \s -> do
    (a, s') <- sma s
    runStateT (f a) s'
:}
#+END_SRC

* 26.6 Types You Probably Don't Want To Use
...
