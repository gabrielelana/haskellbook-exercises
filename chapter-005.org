* 5.1 Types
  Type systems in logic and mathematics have been designed to impose
  constraints that enforce correctness.

* 5.2 What are types for?
- Reduces errors.
- Enables optimizations.
- Reduces number of trivial tests.
- Serves as documentation.

* 5.3 How to read type signatures
- The arrow is the type constructor for functions (~data (->) a b~)
- Function type has no data constructors. The values that shows up at term level is the function. Functions are values.
- ~(+) :: a -> a -> a~ right associative ~(->) a (a -> a)~ mean takes and ~a~ and returns a ~(a -> a)~
- When a typeclass is constraining a type variable, the variable could represent one of the types that have instances of that typeclass.
- When we constrain a type varialbe like ~Num a => a -> a~ means also that the first and the second argument must be of the same concrete type when found.
- A type signature can have more than one typeclass constraint (~(Ord a, Num a) => a -> a -> Ordering~)
- Look up [[https://wiki.haskell.org/Keywords][here]] to learn the keywords of the language
- The only way to evaluate anything is to evaluate a function
- Function evaluation is left associative -> left most arguments are evaluated first
** Exercise: Type Matching
   1. a -> c
   2. b -> d
   3. c -> b
   4. d -> a
   5. e -> e

* 5.4 Currying
- Partial Application
  #+BEGIN_SRC haskell :results output replace
  :{
  addFive :: Integer -> Integer -> Integer
  addFive a b = a + b + 5
  :}

  0
  :t addFive
  addTen = addFive 5
  :t addTen
  fifteen = addTen 5
  :t fifteen
  fifteen
  0
  #+END_SRC

  #+RESULTS:
  : addFive :: Integer -> Integer -> Integer
  : addTen :: Integer -> Integer
  : fifteen :: Integer
  : 15
- Manual currying and uncurrying
- Sectioning: specifically refers to partial application of infix operators, which has a special syntax and allows you to choose whether the argument you're applying the operator to is the first or the second.
  #+BEGIN_SRC haskell :results output replace
  x = 5
  y = (2^)
  z = (^2)

  y x
  z x
  0
  #+END_SRC

  #+RESULTS:
  : 32
  : 25
** Exercise: Type Arguments
1. ~f :: a -> a -> a -> a~ what is the type of ~f 'c'~
   a) ~Char~
2. ~g :: a -> b -> c -> b~ what is the type of ~g 0 'c' "woot"~
   d) ~Char~
3. ~h :: (Num a, Num b) => a -> b -> b~ what is the type of ~h 1.0 2~
   d) ~Num b => b~
4. ~h :: (Num a, Num b) => a -> b -> b~ what is the type of ~h 1 (5.5 :: Double)~
   c) ~Double~
5. ~jackal :: (Ord a, Eq b) => a -> b -> a~ what is the type of ~jackal "keyboard" "has the word jackal in it"~
   a) ~Char~
6. ~jackal :: (Ord a, Eq b) => a -> b -> a~ what is the type of ~jackal "keyboard"~
   e) ~Eq b => b -> [Char]~
7. ~kessel :: (Ord a, Num b) => a -> b -> a~ what is the type of ~kessel 1 2~
   d) ~(Num a, Ord a) => a~
8. ~kessel :: (Ord a, Num b) => a -> b -> a~ what is the type of ~kessel 1 (2 :: Integer)~
   a) ~(Num a, Ord a) => a~
9. ~kessel :: (Ord a, Num b) => a -> b -> a~ what is the type of ~kessel (1 :: Integer) 2~
   c) ~Integer~
