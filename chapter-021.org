# -*- eval: (org-babel-lob-ingest "./ob-haskell-common.org"); -*-

#+TITLE: Traversable

#+PROPERTY: header-args:haskell :results replace output
#+PROPERTY: header-args:haskell+ :noweb yes
#+PROPERTY: header-args:haskell+ :wrap EXAMPLE

* 21.01 Traversable
~Traversable~ allows you to transform elements inside the structure
like a functor, producing applicative effects along the way, and lift
those potentially multiple instances of applicative structure outside
of the traversable structure.

* 21.02 The Traversable Typeclass Definition
#+BEGIN_SRC haskell :eval never
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  traverse = undefined

  sequenceA :: Applicative f => t (f a) -> f (t a)
  sequenceA = undefined
#+END_SRC

Extends ~Functor~ and ~Foldable~ and use ~Applicative~. You need to
provide at least an implementation of ~traverse~ or ~sequenceA~, both
can be implemented in terms of in each other.

#+BEGIN_SRC eval :never
-- If you have `sequenceA` you can implement `traverse`
traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
traverse = sequenceA . fmap f

-- If you have `traverse` you can implement `sequenceA`
sequenceA :: Applicative f => t (f a) -> f (t a)
sequenceA = traverse id
#+END_SRC

* 21.03 SequenceA
The effect of ~sequenceA~ is flipping two contexts or structures.

#+BEGIN_SRC haskell
-- application of sum to a foldable structure ([])
sum [1, 2, 3]

-- application of sum to a foldable structure (Maybe) inside another
-- structure ([]). Remember that `sum (Just 1) == 1`
fmap sum [Just 1, Just 2, Just 3]
fmap sum [Just 1, Nothing, Just 3]

-- application of sum to a foldable structure ([]) inside another
-- structure (Maybe)
fmap sum (Just [1, 2, 3])
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
6
[1,2,3]
[1,0,3]
Just 6
#+END_EXAMPLE

#+BEGIN_SRC haskell
-- creates a list of maybes
fmap Just [1, 2, 3]

-- from a list of maybes to a maybe of a list
sequenceA $ fmap Just [1, 2, 3]

-- what happens with Nothing?
sequenceA $ [Just 1, Nothing, Just 3]

-- apply sum after swapping the structure
fmap sum $ sequenceA [Just 1, Just 2, Just 3]
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
[Just 1,Just 2,Just 3]
Just [1,2,3]
Nothing
Just 6
#+END_EXAMPLE

* 21.04 Traverse
We are mapping a function over some values in some structure, that
function is also generating more structure but that structure can be
different.

Compare ~traverse~ with ~fmap~ and ~=<<~ (aka flip bind) to see what
changes.

#+BEGIN_SRC haskell :eval never
fmap     :: _ => (a -> b) -> f a -> f b

-- the given function maps `a` values to a value `b` in a structure
-- `m`, the same structure `m` that contains the `a` values
(=<<)    :: _ => (a -> m b) -> m a -> m b

-- the given function maps `a` values to a value `b` in a structure
-- that is different
traverse :: _ => (a -> f b) -> t a -> f (t b)
#+END_SRC

#+BEGIN_SRC haskell
fmap Just [1, 2, 3]
sequenceA $ fmap Just [1, 2, 3]
sequenceA $ [Just 1, Just 2, Just 3]
traverse Just [1, 2, 3]
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
[Just 1,Just 2,Just 3]
Just [1,2,3]
Just [1,2,3]
Just [1,2,3]
#+END_EXAMPLE

NOTE: ~mapM~ is the specialization for monads of ~traverse~
~mapM     :: (Monad m, Functor t, Foldable t)       => (a -> m b) -> t a -> m (t b)~
~traverse :: (Applicative f, Functor t, Foldable t) => (a -> f b) -> t a -> f (t b)~

NOTE: ~sequence~ is the specialization for monads of ~sequenceA~
~sequence :: (Monad m, Functor t, Foldable t)        => t (m a) -> m (t a)~
~sequenceA :: (Applicative f, Functor t, Foldable t) => t (f a) -> f (t a)~

QUESTION: In the book (pp. 827) seems like ~sequenceA~ is defined with
a given constraint ~Traversable t~ where the definition of ~sequenceA~
should be required to have an instance of ~Traversable~ on ~t~. Is
this wrong?

* 21.05 What's Traversable for?
Anytime you need to flip two type constructors around, or map
something and then flip them around, thatâ€™s probably Traversable.

#+BEGIN_SRC haskell
f = undefined :: a -> Maybe b
xs = undefined :: [a]
:t map f xs

-- what if we want a ~Maybe [b]~
:t sequenceA $ map f xs
:t traverse f xs
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
map f xs :: [Maybe b]
sequenceA $ map f xs :: Maybe [a]
traverse f xs :: Maybe [b]
#+END_EXAMPLE

* 21.06 Morse Code Revisited
How can we improve the previous implementation of ~Morse~?

~stringToMorse :: String -> Maybe [Morse]~ was implemented with the
following pattern
#+BEGIN_SRC haskell :eval never
stringToMorse :: String -> Maybe [Morse]
stringToMorse s = sequence $ fmap charToMorse s
#+END_SRC

We want to go from ~[Maybe Morse]~ to ~Maybe [Morse]~ but ~catMaybes
:: [Maybe a] -> [a]~ it's not ok because it will simply eliminate the
nothings whereas we want to end up with a ~Nothing~ if there's one
~Nothing~ in the whole ~Traversable~ structure.

~traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)~
is what we need

#+BEGIN_SRC haskell
<<add-chapter-directory-in-path(chapter="chapter-014/morse-code/src")>>
:load Morse

:t stringToMorse

:{
stringToMorse' :: String -> Maybe [Morse]
stringToMorse' = traverse charToMorse
:}

stringToMorse "hello"
stringToMorse' "hello"
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
[1 of 1] Compiling Morse            ( /home/coder/code/haskellbook-exercises/chapter-014/morse-code/src/Morse.hs, interpreted )
Ok, one module loaded.
stringToMorse :: String -> Maybe [Morse]
Just ["....",".",".-..",".-..","---"]
Just ["....",".",".-..",".-..","---"]
#+END_EXAMPLE

* 21.07 Axing Tedious Code
Take the following code as example (it should only compile)

#+NAME: tedious-preamble
#+BEGIN_SRC haskell :eval never
data Query = Query
data SomeO = SomeO
data OnlyO = OnlyO
data Error = Error

:{
-- decode and object from a string
decodeFn :: String -> Either Error SomeO
decodeFn = undefined
:}

:{
-- performs (IO) a query and fetches some strings
fetchFn :: Query -> IO [String]
fetchFn = undefined
:}

:{
makeOnlyO :: [SomeO] -> IO [(SomeO, OnlyO)]
makeOnlyO = undefined
:}
#+END_SRC

#+BEGIN_SRC haskell :results silent
<<tedious-preamble>>

:{
pipelineFn :: Query -> IO (Either Error [(SomeO, OnlyO)])
pipelineFn query = do
  a <- fetchFn query
  case sequence (map decodeFn a) of
    (Left err) -> return $ Left err
    (Right res) -> do
      a <- makeOnlyO res
      return $ Right a
:}
#+END_SRC

Can be refactored? We can notice
- The use of ~sequence~ and ~map~ that smells like ~traverse~
- The explicit case on the ~sequence~ result

#+BEGIN_SRC haskell :results silent
<<tedious-preamble>>

:{
pipelineFn :: Query -> IO (Either Error [(SomeO, OnlyO)])
pipelineFn query = do
  a <- fetchFn query
  -- given traverse decodeFn a :: Either Error (t SomeO)
  -- we have makeOnlyO :: [SomeO] -> IO [(SomeO, OnlyO)]
  -- we want IO (Either Error [(SomeO, Only)])
  -- we can fmap makeOnlyO :: Either Error (IO [(SomeO, OnlyO)])
  -- so we need to swap Either and IO with sequenceA -> traverse
  traverse makeOnlyO $ traverse decodeFn a
:}

-- or more like a pipeline

:{
pipelineFn' :: Query -> IO (Either Error [(SomeO, OnlyO)])
pipelineFn' query =
  fetchFn query >>=
  (\a -> return $ traverse decodeFn a) >>=
  (\b -> traverse makeOnlyO b)
:}
#+END_SRC

* 21.08 Do All The Things
Another example, suppose that you have a means to retrieve the content
of an URL

#+NAME: get-url
#+BEGIN_SRC haskell :results silent
:{
getURL :: String -> IO String
getURL = undefined
:}
#+END_SRC

And we want to retrieve a bunch of URLs

#+NAME: urls
#+BEGIN_SRC haskell
:{
urls :: [String]
urls = undefined
:}
#+END_SRC

We can map the ~getURL~ function on all the URLs

#+BEGIN_SRC haskell :results silent
<<get-url>>
<<urls>>

:{
mapped :: [String] -> [IO String]
mapped = map getURL
:}
#+END_SRC

But we end up with a list of IO actions, it will be better to have one
single IO action that produces a list of responses (aka ~IO [String]~)
and that's the job of traverse

#+BEGIN_SRC haskell :results silent
<<get-url>>
<<urls>>

:{
traversed :: [String] -> IO [String]
traversed = traverse getURL
:}
#+END_SRC

** Strength for understanding

~Traversable~ is stronger that ~Functor~ and ~Foldable~ and, as with
~Monad~ you can implement the ~Functor~ and ~Applicative~
representative functions, with ~Traversable~ you can implement the
representative functions of ~Functor~ and ~Foldable~

Given ~Traversable~ implement
~tMap :: Traversable t => (a -> b) -> t a -> t b~

#+BEGIN_SRC haskell
import Data.Functor.Identity
-- we can use Identity

traverse (Identity . (+1)) [1, 2]
runIdentity $ traverse (Identity . (+1)) [1, 2]

:{
tMap :: Traversable t => (a -> b) -> t a -> t b
tMap f = runIdentity . traverse (Identity . f)
:}

tMap (+1) [1, 2]
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
[2,3]
[2,3]
[2,3]
#+END_EXAMPLE

Given ~Traversable~ implement
~tFoldMap :: (Traversable t, Monoid m) => (a -> m) -> t a -> m~

#+BEGIN_SRC haskell
import Data.Monoid
import Data.Functor.Constant

traverse (Constant . Sum) [1, 2]
:t traverse (Constant . Sum) [1, 2]
getConstant $ traverse (Constant . Sum) [1, 2]

-- QUESTION:
-- why the type is (Num a => Constant (Sum a) [b])
-- and not (Num a => Constant ([Sum a]) b)
-- ???

:{
tFoldMap :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
tFoldMap f = getConstant . traverse (Constant . f)
:}

tFoldMap Sum [1, 2]
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Constant (Sum {getSum = 3})
traverse (Constant . Sum) [1, 2] :: Num a => Constant (Sum a) [b]
Sum {getSum = 3}
Sum {getSum = 3}
#+END_EXAMPLE

* 21.09 Traversable Instances
...

* 21.10 Traversable Laws
...

* 21.11 Quality Control
...

* 21.12 Exercises
...
