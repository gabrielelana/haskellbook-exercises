# -*- eval: (org-content 2); -*-

#+TITLE: HaskellBook Flash Cards

* Chapter 01
** What is a calculus?                                                                      :drill:
*** Answer
Is a method of calculation and reasoning
** What is functional programming?                                                          :drill:
*** Answer
Functional programming is a computer programming paradigm that relies
on functions modeled on mathematical functions.
** Sentence                                                                                 :drill:
Programs are <[combination]> of <[expressions]>
** Sentence                                                                                 :drill:
Functions are expressions that are <[applied]> to an argument and once
<[applied]> they can be <[reduced]>
** What brings purity in a programming language?                                            :drill:
*** Answer
Higher degree of abstraction and composability.
** Sentence                                                                                 :drill:
A /lambda term/ can be an <[/expression/]> a <[/variable/]> or an
<[/abstraction/]>. An <[/expression/]> can be both or a combination of
them.
** What is an abstraction in lambda calculus?                                               :drill:
*** Answer
It's a function, it has an /head/ and a /body/. The /head/ is a lambda
sign followed by a variable. The /body/ is a lambda /expression/.
** Why functions are called abstractions?                                                   :drill:
*** Answer
It's called abstraction because it's a generalization from a concrete
instance of a problem by introducing names. When we apply the
abstraction to an argument we replace names with values making it
concrete again
** What is an /Alpha Equivalence/?                                                          :drill:
*** Answer
Names have no meaning so ~λx.x~ and ~λy.y~ are the same function.
** What is a /Beta Reduction/?                                                              :drill:
*** Answer
When we apply a function we perform a /Beta Reduction/: we substitute
the input expression for all instances of the variable in the body of
the abstraction and eliminate the head of the abstraction.
** What is a /Free Variable/?                                                               :drill:
*** Answer
Is a variable that is not bound in the head of the abstraction
(function). In ~λx.xy~ then ~x~ is a /bound variable/ and ~y~ is a
/free variable/. The /alpha equivalence/ doesn't apply to /free
variables/.
** Sentence                                                                                 :drill:
Each lambda can only bind one <[parameter]> and can only bind one
<[argument]>. Functions with multiple arguments have <[nested heads]>.
** What is called /Currying/?                                                               :drill:
*** Answer
The fact that each lambda can bind only one parameter and apply only
one argument is called /currying/ named after the mathematician
Haskell Curry.
** The following lambda term reduces to?                                                    :drill:
~(λxyz.xz(yz))(λmn.m)(λp.p)~
*** Answer
~λz.z~
** When a term is in /Beta Normal Form/?                                                    :drill:
*** Answer
When we cannot beta reduce it any further, aka we cannot apply lambdas
to arguments, aka the expression is fully evaluated, aka the program
is fully executed.
** What's a combinator?                                                                     :drill:
*** Answer
It's a lambda term with no free variables.
** What's the purpose of a combinator                                                       :drill:
*** Answer
To combine the arguments that are given. They can only combine the
arguments they cannot introduce new values (no /free variables/)
** When we say that a term diverge?                                                         :drill:
*** Answer
When the beta reduction process never ends, like for ~(λx.xx)(λx.xx)~
** What's the meaning of Haskell programs?                                                  :drill:
*** Answer
Is to evaluate expressions rather than executing instructions.
** The following lambda term will reduce to...                                              :drill:
~(λxyz.xz(yz))(λx.z)(λx.a)~
*** Answer
~(λz.ka)~ where ~k~ is the ~z~ free variable in ~(λx.z)~ renamed to
~k~ because ~z~ is bound in ~(λxyz.xz(yz))~ so they are not the same
variable therefore ~z~ must be renamed in something else
** What's the /Normal Order/ of evaluation in lamdba calculus?                              :drill:
*** Answer
Means evaluating the leftmost and outermost lambda first, evaluating
terms nested within after you've run out of arguments to apply.
* Chapter 02
** What is Prelude?                                                                         :drill:
*** Answer
Prelude is a library of standard functions that is automatically
loaded both from GHC and GHCi
** When an expression is in /Normal Form/?                                                  :drill:
*** Answer
We say that an expression is in /Normal Form/ when there are no more
evaluation steps that can be take AKA when it is in an irreducible
form.
** Identify the parts of a function definition                                              :drill:
#+BEGIN_SRC haskell :eval never
triple x    =  x * 3
-- [1] [2] [3] [4]
#+END_SRC
*** Answer
1. The /name/ of the function
2. The /formal parameter/ of the function (like the head of the
   lambda)
3. The ~=~ will separate the /definition/ from the /implementation/
4. The /body/ or the /implementation/ of the function
** What it means to evaluate an expression?                                                 :drill:
*** Answer
When we talk about evaluating an expression we're talking about
reducing the terms until the expression reaches its simplest form, we
say that it's /irreducible/ and we call this a value.
** What it means to be left associative for an operator?                                    :drill:
*** Answer
A left associative operator is applied starting from the left

#+BEGIN_SRC haskell
7 * 5 * 10
#+END_SRC

Is equivalent to

#+BEGIN_SRC haskell
((7 * 5) * 10)
#+END_SRC
** What it means to be right associative for an operator?                                   :drill:
*** Answer
A right associative operator is applied starting from the right

#+BEGIN_SRC haskell
(*) 5 $ (+) 10 $ 5 * 5
#+END_SRC

Is equivalent to

#+BEGIN_SRC haskell
(*) 5 $ ((+) 10 $ (5 * 5))
#+END_SRC
** Order of declaration matters in a file?                                                  :drill:
*** Answer
No
** Indentation matters?                                                                     :drill:
*** Answer
Yes
** Law of quotient and reminders for ~div~                                                  :drill:
*** Answer
#+BEGIN_SRC haskell
(div x y) * y + (mod x y) == x
#+END_SRC
** Law of quotient and reminders for ~quot~                                                 :drill:
*** Answer
#+BEGIN_SRC haskell
(quot x y) * y + (rem x y) == x
#+END_SRC
** What is /sectioning/?                                                                    :drill:
*** Answer
Operators can be partially applied on the left and on the right, this
is called ~sectioning~

#+BEGIN_SRC haskell :eval never
(^3) 6
(3^) 6
#+END_SRC
** For what are used ~let~ and ~where~?                                                     :drill:
*** Answer
They are used to introduce components of an expression
** Where can be used ~let~?                                                                 :drill:
*** Answer
~let~ introduces an /expression/ so it can be used wherever you can
have an expression
** Where can be used ~where~?                                                               :drill:
*** Answer
~where~ is a /declaration/ so it is bound to the surrounding syntactic
construct
** What's a /parameter/?                                                                    :drill:
*** Answer
A /parameter/ or /formal parameter/ represents a value that will be
passed to the function when the function is called.
** What's an /argument/?                                                                    :drill:
*** Answer
An /argument/ is a value the function is applied to.

* Chapter 03
** What type is String?                                                                     :drill:
*** Answer
Is a type alias of list of ~Char~ aka ~[Char]~

#+BEGIN_SRC haskell :eval never
type String = [Char]
#+END_SRC
** What is a String?                                                                        :drill:
*** Answer
A /String/ is a sequence of characters.
** What is a /Type/?                                                                        :drill:
*** Answer
A /Type/ is a classification of values or data.
** What is the /Scope/?                                                                     :drill:
*** Answer
/Scope/ is where a variable referred to by name is valid.
** What are the /Local Bindings/?                                                           :drill:
*** Answer
/Local Bindings/ are bindings local to particular expressions.
** What are /Top Level Bindings/?                                                           :drill:
*** Answer
/Top Level Bindings/ are bindings that stand outside of any other
declaration.
* Chapter 04
** What are types?                                                                          :drill:
:PROPERTIES:
:ID:       2c2d67f2-ec90-4a5f-a5f7-b322bec5a247
:END:
*** Answer
Are how we group a set of values together that share something in
common
** What is ~data Bool = True | False~?                                                      :drill:
:PROPERTIES:
:ID:       56f87207-45ef-4590-85b3-6c4f73867521
:END:
*** Answer
Is a /Data Declaration/
** What is ~Bool~ in ~data Bool = True | False~?                                            :drill:
:PROPERTIES:
:ID:       be1821b2-2773-492a-8b16-0ac5393c59be
:END:
*** Answer
Is a /Type Constructor/
** What is ~True~ in ~data Bool = True | False~?                                            :drill:
:PROPERTIES:
:ID:       88419a7e-e35e-4ea1-b7ee-ddddec40873a
:END:
*** Answer
Is a /Data Constructor/
** What's a Data Declaration?                                                               :drill:
:PROPERTIES:
:ID:       665a09cb-092f-4d47-ae95-bba993381897
:END:
*** Answer
How datatypes are defined
** What's a Type Constructor                                                                :drill:
:PROPERTIES:
:ID:       56eaab13-4f63-4b6d-8949-5a06dd869ffd
:END:
*** Answer
How we define the name of a type. Type constructors are used at type
level
** What's a Data Constructor?                                                               :drill:
:PROPERTIES:
:ID:       b9079175-a6f3-46bc-a25b-6746a661fd45
:END:
*** Answer
Are the values that inhabit the type they are defined in. Data
constructors are used at term level.
** What's the type of ~8~?                                                                  :drill:
:PROPERTIES:
:ID:       30603e40-ebf4-44ef-ae11-83450fb7c1e0
:END:
*** Answer
Numbers are polymorphic, the compiler doesn't assign them a concrete
type until is not forced to do so. In this case we cannot tell
** What are the ~Integral~ number types                                                     :drill:
:PROPERTIES:
:ID:       b03fd700-6876-4c67-bfa2-28d16d7ff405
:END:
*** Answer
Int, Integer, Word
** What are the ~Fractional~ number types                                                   :drill:
:PROPERTIES:
:ID:       9408ed3c-593f-45a8-98b6-c82c6a4e8315
:END:
*** Answer
Float, Double, Rational, Fixed, Scientific
** What's the type signature of ~==~                                                        :drill:
:PROPERTIES:
:ID:       0826e63c-0b5c-4c27-bcbd-c6eaeb8a5ba8
:END:
*** Answer
~(==) :: Eq a => a -> a -> Bool~
** What's the type signature of ~<~                                                         :drill:
:PROPERTIES:
:ID:       ff12a4b8-05fa-4014-8402-ba62bbb6d624
:END:
*** Answer
~(<) :: Ord a => a -> a -> Bool~
** ~if~ it's a statement or an expression?                                                  :drill:
:PROPERTIES:
:ID:       62d15637-c5d0-4442-a29f-d8ff2073cf3e
:END:
*** Answer
It's an expression
** What's the type signature of ~fst~?                                                      :drill:
:PROPERTIES:
:ID:       595d15bf-64a4-4897-b53d-985366992a94
:END:
*** Answer
~fst :: (a, b) -> a~
** What's the type signature of ~snd~                                                       :drill:
:PROPERTIES:
:ID:       8de0c7e8-25df-4276-8608-941fce812c34
:END:
*** Answer
~snd :: (a, b) -> b~
** What's the type signature of ~swap~?                                                     :drill:
:PROPERTIES:
:ID:       4a59f7d2-7dc2-4805-8a98-db2747991849
:END:
*** Answer
~swap :: (a, b) -> (b, a)~
* Chapter 05
** What's the output of ~:t 13~                                                             :drill:
:PROPERTIES:
:ID:       1f1e2410-fe95-4d3c-9403-ad7e1185846b
:END:
*** Answer
~13 :: Num p => p~
** What's the arrow (~->~)                                                                  :drill:
:PROPERTIES:
:ID:       c6e5b127-7dfb-487a-b902-b905092309b5
:END:
*** Answer
It's a /Type Constructor/ without a /Data Constructor/, it shows up only at type level and not at term level.
** The arrow ~(->)~ is left of right associative?                                           :drill:
:PROPERTIES:
:ID:       3f690bd9-927b-4c19-ba3f-e834e2bd0328
:END:
*** Answer
Is right associative, it means that ~(+) :: a -> a -> a~ it takes an
~a~ and returns a function ~(a -> a)~
** Function application is left or right associative?                                       :drill:
:PROPERTIES:
:ID:       62a423e6-8ff4-4a08-8620-a946a9af1651
:END:
*** Answer
If left associative, it means that ~f g 5~ will be applied as ~(f g) 5~
** What it means that a /Type Class/ is constraining a /Type Variable/?                     :drill:
:PROPERTIES:
:ID:       b5f3dfa9-c7b0-4aaf-aa25-84294dd9ad05
:END:
*** Answer
It means that the variable represents one of the types that have
instances of that /Type Class/
** How do you write that the /Type Variable/ ~a~ is constrained with /Type Class/ ~Num~?    :drill:
:PROPERTIES:
:ID:       d206609a-1e04-4cda-8f1b-224b29198671
:END:
*** Answer
~Num a => a~
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       43e2f362-849f-44f8-a404-af0d845d6e1d
:END:
All <[functions]> in Haskell take <[one]> argument and return <[one]>
result
** Describe in words ~(+) :: Num a => a -> a -> a~                                          :drill:
:PROPERTIES:
:ID:       ab7ffc67-30cf-40df-836a-d11c9be4ebc5
:END:
*** Answer
It's a function that takes and argument of type ~a~ constrained by
~Num a~ and returns a function that takes and argument of the same
type ~a~ and returns a value of the same type ~a~.
** Describe in words ~map :: (a -> b) -> [a] -> [b]~                                        :drill:
:PROPERTIES:
:ID:       9211875b-d323-4a8d-95f7-d56c5b5dea3a
:END:
*** Answer
It's a function that takes a function from type ~a~ to type ~b~ and
returns a function that takes a list of values of type ~a~ and returns
a list of values ~b~
** Transformation from ~f :: (t1, t2) -> t3~ to ~f' :: t1 -> t2 -> t3~ is called...         :drill:
:PROPERTIES:
:ID:       13ec56c5-2f89-489b-8c14-5fcf068b0531
:END:
*** Answer
Curring
** Transformation from ~f :: t1 -> t2 -> t3~ to ~f' :: (t1, t2) -> t3~ is called...         :drill:
:PROPERTIES:
:ID:       6ac4dce2-46d1-4df5-a171-58cb50b2dc92
:END:
*** Answer
Unurring
** Write a function to curry a function ~(t1, t2) -> t3~                                    :drill:
:PROPERTIES:
:ID:       e7cae766-9d1a-4007-b1a8-be26fee5774a
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
curry :: ((t1, t2) -> t3) -> t1 -> t2 -> t3
curry f a b = f (a, b)
#+END_SRC
** Write a function to uncurry a function ~t1 -> t2 -> t3~                                  :drill:
:PROPERTIES:
:ID:       8b03d20b-505a-43be-94ca-8cb0546e3ab6
:END:
*** Answer
#+BEGIN_SRC haskell
uncurry :: (t1 -> t2 -> t3) -> (t1, t2) -> t3
uncurry f (a, b) = f a b
#+END_SRC
** What's /Sectioning/?                                                                     :drill:
:PROPERTIES:
:ID:       d810fee9-1955-43e8-8594-6ece718d9d06
:END:
*** Answer
Partial application of infix operators. ~(2^)~ leaves the remaining
argument to the right or ~(^2)~ leaving the remaining argument to the
left.
** What means /Polymorphic/?                                                                :drill:
:PROPERTIES:
:ID:       74302f15-0ea0-4c75-b972-cc4395f3f38d
:END:
*** Answer
It means "made of many forms". Polymorphic type variables give us the
ability to implement expressions that can accept arguments of many
types and results of many types without rewriting the expression for
every type.
** Type variables can be: ...                                                               :drill:
:PROPERTIES:
:ID:       20eaf096-8900-480a-86ed-e51b203fbf0d
:END:
*** Answer
- Concrete
- Constrained Polymorphic (also called /Ad-Hoc Polymorphism/)
- Parametric Polymorphic
** A function is /Polymorphic/ when?                                                        :drill:
:PROPERTIES:
:ID:       c7f05602-864d-4804-9454-db7bde34d9c2
:END:
*** Answer
A function is polymorphic when its type signature has variables that
can represent more than one type.
** What's the /Parametricity/ property?                                                     :drill:
:PROPERTIES:
:ID:       c37ce399-d331-41b3-a4ba-2b204f0ce4d7
:END:
*** Answer
Parametricity is the property we get from having parametric
polymorphism. Parametricity means that the behavior of a function with
respect to the types of its arguments is uniform. The behavior cannot
change just because it was applied to an argument of a different type.
** What's a /Polymorphic Constant/?                                                         :drill:
:PROPERTIES:
:ID:       fa04ad83-d5d0-4ba6-8176-0cc03b59def5
:END:
*** Answer
A value whose concrete type is left to be decided. Ex ~[]~ which has
type ~[a]~ or ~1~ which has type ~Num a => a~.
** What's a /Principal Type/?                                                               :drill:
:PROPERTIES:
:ID:       614d06ae-ecd6-4977-9247-ae160014c097
:END:
*** Answer
Is the most generic type which still type checks.
** What's a /Type Class/?                                                                   :drill:
:PROPERTIES:
:ID:       60107c70-6056-47af-b09c-e14113e1abf0
:END:
*** Answer
Is a means of expressing faculties or interfaces that multiple
datatypes have in common.
** What's a /Module/?                                                                       :drill:
:PROPERTIES:
:ID:       b20dd244-9ccd-4a3b-8f71-d2a3decf14d6
:END:
*** Answer
Is the unit of organization that Haskell uses to collect together
declarations of values, functions, datatypes, type classes, and type
classes instances.

* Chapter 06
** In what sense Typeclasses are the opposite of Datatypes?                                 :drill:
:PROPERTIES:
:ID:       91055e7a-1f5a-4a2f-b961-9fe795ac3752
:END:
*** Answer
Because /Datatypes/ defines how /Types/ are created whereas
/Typeclasses/ defines how /Types/ are consumed (used in a
computation).
** What's the relationship between Typeclasses and their instances?                         :drill:
:PROPERTIES:
:ID:       31129382-0564-4817-856a-2dee25618d78
:END:
*** Answer
/Typeclasses/ defines functions and values. /Typeclasses/ instances
supply an implementation of those functions and values for a specific
/Type/.
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       dd25510c-4c3d-4047-a9c0-898ae4cf12b8
:END:
Typeclasses allow us to <[generalize]> over a set of <[/types/]> in
order to define and execute a standard set of <[functions]> for those
<[types]>
** List some well known Typeclasses                                                         :drill:
:PROPERTIES:
:ID:       3ecc0dc9-4695-4984-b23d-73af3f5c6737
:END:
*** Answer
- Eq
- Show
- Ord
- Enum
- Bounded
- Num
** What does it mean for a Type to have an instance of a Typeclass?                         :drill:
:PROPERTIES:
:ID:       6363288a-2388-4d38-8244-4269f46e148f
:END:
*** Answer
To have an implementation of every (required) function defined in the
Typeclass.
** List all the methods defined in ~Eq~ Typeclass                                           :drill:
:PROPERTIES:
:ID:       9140d1a7-501a-4445-a9e1-375e3276308d
:END:
*** Answer
- ~(==) :: a -> a -> Bool~
- ~(/=) :: a -> a -> Bool~
** Define an instance of Typeclass ~Eq~ for the following Type                              :drill:
:PROPERTIES:
:ID:       a0d39dd2-13a3-40ab-997b-680dd199cfc9
:END:
#+BEGIN_SRC haskell
data Trivial = Trivial
#+END_SRC
*** Answer
#+BEGIN_SRC haskell
instance Eq Trivial where
  (==) Trivial Trivial = True
#+END_SRC
** What are partial functions?                                                              :drill:
:PROPERTIES:
:ID:       d414f081-be84-4fa7-9548-a8981ff9d5c0
:END:
*** Answer
Functions that are not defined for all possible input. Haskell will
refuse to compile such functions.
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       906c121e-ced1-4a97-bc7c-eaebfb06a86e
:END:
*** Answer
For a <[polymorphic]> datatype we can ask, for one or more <[type
argument]>, to implement one or more <[Typeclass]>
** Write an instance of Typeclass ~Eq~ for the following Datatype                           :drill:
:PROPERTIES:
:ID:       0f0a2a72-bda0-4cd5-9087-d28bb7d32366
:END:
#+BEGIN_SRC haskell
data Pair a = Pair a a
#+END_SRC
*** Answer
#+BEGIN_SRC haskell
instance Eq a => Eq (Pair a) where
  (==) (Pair l1 l2) (Pair r1 r2) =
    l1 == r1 && l2 == r2
#+END_SRC
** How can a Typeclass inherith from another?                                               :drill:
:PROPERTIES:
:ID:       ca5d7efe-df2c-4954-af75-b0b22f020459
:END:
*** Answer
In the definition of a /Typeclass/ you can require the /Type/ to
already implement another /Typeclass/ (NOTE: that is not the same as
requiring a type to implement another /Typeclass/ when you define
another /Typeclass/ implementation)

#+BEGIN_SRC haskell :eval never
class (Real a, Enum a) => Integral a where ...
#+END_SRC

Any type that implements ~Integral~ must implement already ~Real~ and
~Enum~
** Why Typeclasses don't suffer from multiple inheritance problems?                         :drill:
:PROPERTIES:
:ID:       0e89feb7-be9d-469d-ae9f-9d99aed588ad
:END:
*** Answer
Because /Typeclasses/ inheritance is addictive, an implementation of a
method of a /Typeclass/ cannot override the implementation of another.
** What is /Type Defaulting/?                                                               :drill:
:PROPERTIES:
:ID:       09241a11-3199-42aa-a4dd-116ce303e185
:END:
*** Answer
Is when a /Typeclass/ constrained polymorphic value needs to be
resolved and it cannot be resolved either by declaration (~5 ::
Double~) or by type inference then the polymorphism is resolved using
the /Typeclass/ default type value (ex. for ~5~ the /Typeclass/ is
~Num~ and the default type of ~Num~ is ~Integer~)
** Question?                                                                                :drill:
:PROPERTIES:
:ID:       e0779f8d-fdd8-4ea4-a89f-048f37adb543
:END:
What is used, besides declaration and type inference, to resolve the
polymorphism of a value?
*** Answer
/Type Defaulting/, every Typeclass have a default type value, ~Enum~
has ~Integer~ as default, ~Fractional~ has ~Double~ as default.
** What's ~Ord~ /Typeclass/ for?                                                            :drill:
:PROPERTIES:
:ID:       c76bc27f-e151-4243-ac54-c215b4718e17
:END:
*** Answer
For things that can be put in order
** List all the methods in ~Ord~ /Typeclass/                                                :drill:
:PROPERTIES:
:ID:       1c9a1c10-7e48-4a09-9e1d-2b978ba11beb
:END:
*** Answer
- ~compare :: a -> a -> Ordering~
- ~(<) :: a -> a -> Bool~
- ~(<=) :: a -> a -> Bool~
- ~(>) :: a -> a -> Bool~
- ~(>=) :: a -> a -> Bool~
- ~max :: a -> a -> a~
- ~min :: a -> a -> a~
** What's ~Enum~ /Typeclass/ for?                                                           :drill:
:PROPERTIES:
:ID:       5ec1663f-2b30-4e73-960a-437eddbba34d
:END:
*** Answer
For things that have a predecessor and a successor
** What's ~Show~ /Typeclass/ for?                                                           :drill:
:PROPERTIES:
:ID:       8de4ca42-df7b-4c8f-a1f7-c89411d38023
:END:
*** Answer
To provide human readable string representations of structured data.
** What's ~()~?                                                                             :drill:
:PROPERTIES:
:ID:       39cd56e1-166c-4207-bfb5-1911dd1c10a4
:END:
*** Answer
Is called /Unit/, it's a value and also a type that has only one
habitant, it essentially represents nothing.
** What's the most representative method of ~Show~ /Typeclass/?                             :drill:
:PROPERTIES:
:ID:       6e5ef46b-e0e1-4ce5-9ace-3f2f515b150e
:END:
*** Answer
~show :: a -> String~
** What's ~Read~ /Typeclass/ for?                                                           :drill:
:PROPERTIES:
:ID:       320bfb02-7341-4e2e-8886-f52cefe4d51d
:END:
*** Answer
Interpret a string into a structured data.
** What's the most representative method of ~Read~ /Typeclass/?                             :drill:
:PROPERTIES:
:ID:       ac31c492-45c2-41ca-83eb-6f1ea9a56698
:END:
*** Answer
~read :: String -> a~ which is a partial function (we cannot guarantee
that for every string we can create a value of type ~a~) so it should
be avoided.
* Chapter 07
** How variables get bound to values?                                                       :drill:
:PROPERTIES:
:ID:       b59abd8d-5a7b-43cb-8f59-76c1f3ec4b95
:END:
*** Answer
- Apply arguments values to function parameters (~f x = x; f 5~)
- ~let~ expressions (~let x = 5 in ...~)
- ~where~ statements (~where x = 5~)
- Pattern matching (~x:_ = [5, 6, 7]~)
- Declaration (~x = 5~)
** Sentence                                                                                 :drill:
SCHEDULED: <2019-05-09 Thu>
:PROPERTIES:
:ID:       047c0400-84be-458f-b0e8-ecbe03cf6764
:DRILL_LAST_INTERVAL: 4.9644
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-05-04 Sat 10:29]
:END:
Haskell is a <[lexically]> scoped language.
** Write ~triple~ as an anonimous function                                                  :drill:
:PROPERTIES:
:ID:       50bdd368-c864-4c23-94d4-d541ca3abb9d
:END:
*** Answer
~triple = \x -> x * 3~
** When it's useful an anonymous function?                                                  :drill:
:PROPERTIES:
:ID:       b65afc8a-ae5f-41fd-b256-74c25a115e5b
:END:
*** Answer
- When you need to pass it to another function.
- When it's not called anywhere else.
** What's /Pattern Matching/?                                                               :drill:
:PROPERTIES:
:ID:       b46e847f-49dd-4f05-876e-a8f850fd77c7
:END:
*** Answer
A way of matching values against patterns and where appropriate
binding values to successful matches.
** What /Pattern Matching/ is used for?                                                     :drill:
:PROPERTIES:
:ID:       358e59ec-df22-4b51-bdfa-d38f24fafd86
:END:
*** Answer
- Vary what a function does given different input.
- Unpack and expose the contents of our data.
** What's the meaning of ~_~ in a pattern for a /Pattern Match/                             :drill:
:PROPERTIES:
:ID:       fa198000-9dbb-4ed7-bf9d-ad6a1cdb4248
:END:
*** Answer
It's the /Universal Pattern/ that matches everything and doesn't bound
any variable.
** Recall the syntax of a case expression                                                   :drill:
:PROPERTIES:
:ID:       4286d5c2-f481-4df1-9a37-c87d8a61d697
:END:
*** Answer
#+BEGIN_SRC haskell :results none
:{
case 5 > 7 of
  False -> "It works"
  True -> "Run!"
:}
#+END_SRC
** What's an /High Order/ function?                                                         :drill:
:PROPERTIES:
:ID:       60bbe065-32cc-4149-bc9f-0f3fc2da06df
:END:
*** Answer
A function that takes another function as an argument and / or returns
a function as result. Due to currying, in Haskell any function that
appears to take more than one argument is an high order funciton.
** Recall the syntax for /Guard Clauses/                                                    :drill:
:PROPERTIES:
:ID:       76dd7d7a-4aa6-4577-ade4-edb4f6b652b6
:END:
*** Answer
#+BEGIN_SRC haskell :results none
:{
myAbs :: Integer -> Integer
myAbs x
  | x < 0 = (-x)
  | otherwise = x
:}
#+END_SRC
** What's the type of ~(.)~ and how it's called?                                            :drill:
:PROPERTIES:
:ID:       c166deee-f821-42e5-8971-6b400780806a
:END:
*** Answer
/Function Composition/
~(.) :: (b -> c) -> (a -> b) -> a -> c~
** What it means for a function to be written in a /Pointfree Style/?                       :drill:
:PROPERTIES:
:ID:       9a7c7d88-9194-4849-b597-16b48b91b0a9
:END:
*** Answer
It means that is written without specifying the arguments (derives
from topology where there are spaces made of points and functions
between those points, specifying functions without points means
specifying functions without arguments).

In this style functions are made by pure composition or partial
applications of existing functions.

#+BEGIN_SRC haskell :results none
addOne = (+) 1
#+END_SRC

* Chapter 08
** What is the /Bottom/?                                                                    :drill:
*** Answer
In type theory, the bottom type is the type that has no values. It's
also called zero or empty and sometimes denoted with "falsum" ⊥ ("UP
TACK" UTF-8 symbol)
** What should be the result type of a f that returns ~Int~ but also can raise an error?    :drill:
*** Answer
The return type should be ~Int | ⊥~
** Write the function ~fibonacci~ to calculate the fibonacci numbers                        :drill:
*** Answer
#+BEGIN_SRC haskell :results none
:{
fibonacci :: Integral a => a -> a -> a
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
:}
#+END_SRC
** What keyword will declare a type synonym or a type alias?                                :drill:
*** Answer
~type~ ex ~type Numerator = Integer~
** How is commonly named a support function created in a where clause?                      :drill:
*** Answer
~go~
* Chapter 09
** How do you declare the types of a list of ~Integer~?                                     :drill:
*** Answer
~[Integer]~
** Write the definition of list datatype                                                    :drill:
*** Answer
~data [] a = [] | a : [a]~
** List datatype is a sum type or a prod type?                                              :drill:
*** Answer
Both. It's a sum type because ~[] | a : [a]~ and it's a prod type
because ~:~ data constructor takes two arguments.
** How can you pattern match the head and the tail of a list ~xs~?                          :drill:
*** Answer
~(head : tail) = xs~
** How would you define the list ~[1, 2, 3]~ without using the ~[]~ syntactic sugar?        :drill:
*** Answer
~1 : 2 : 3 : []~
** How is it called the ~:~ data contructor for lists?                                      :drill:
*** Answer
It's called /cons/ and ~x : []~ is called a /cons cell/
** What's a list's /Spine/?                                                                 :drill:
*** Answer
The spine is the connective structure that holds the cons cells
together and in place. In general that holds together a data
structure.
** Write a list of numbers from 1 to 10 using sugared ranges                                :drill:
*** Answer
~[1..10]~
** Write a list of numbers from 1 to 10 using desugared ranges                              :drill:
*** Answer
~enumFromTo 1 10~
** Write a recursive function with the following signature and expected behaviour           :drill:
~eft :: (Enum a, Ord a) => a -> a -> [a]~
where
~eft 1 10 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]~
~eft 3 1 == []~
*** Answer
#+BEGIN_SRC haskell :eval never
eft :: (Enum a, Ord a) => a -> a -> [a]
eft x y
  | x > y = []
  | x == y = [x]
  | otherwise = x : (eft (succ x) y)
#+END_SRC
** What's the signature of ~take~? And what's the behaviour?                                :drill:
*** Answer
~take :: Int -> [a] -> [a]~

It will take the first ~n~ elements out of a given list. It works on
the spine of the list.
** What's the signature of ~dropWhile~? And what's the behaviour?                           :drill:
*** Answer
~dropWhile :: (a -> Bool) -> [a] -> [a]~

It will drop elements from a given list until the given predicate is
satisfied and it will return the rest of the list. It works on the
spine.
** What's a list comprehension? Create a list of first 10 odd naturals squared              :drill:
*** Answer
A kind of expression meant to create a new list starting from one or
more lists and optional predicates.

#+BEGIN_SRC haskell
take 10 [ x ^ 2 | x <- [1..], mod 2 x == 0]
#+END_SRC
** Define the condition of an expression to be in /Normal Form/                             :drill:
*** Answer
- The expression is already fully evaluated
** Define the condition of an expression to be in /Weak Head Normal Form/                   :drill:
*** Answer
- The expression is already fully evaluated (/Normal Form/).
- The expression has been evaluated to the point of arriving at a data
  constructor or lambda awaiting an argument.
** Tell in what form (WHNF, NF, NONE) the following expressions are                         :drill:
1. ~(1, 2)~
2. ~(1, 1 + 1)~
3. ~\x -> x * 10~
4. ~"Fizz" ++ "Buzz"~
5. ~[1..10]~
*** Answer
1. WHNF & NF.
2. WHNF. outermost is a data constructor ~(,)~ but arguments are
   not fully evaluated so it is not in NF.
3. WHNF & NF.
4. NONE. there's no lambda or data constructor, only ~+~ not applied
   to arguments fully evaluated.
5. WHNF. outermost is a data constructor ~:~ applied to the rest of
   the list not yet evaluated.
** What it means for a function to be /Spine Strict/?                                       :drill:
*** Answer
It means that it uses only the /Spine/ of the data structure and not
the values contained.
** What it means for a function to be /Value Strict/?                                       :drill:
*** Answer
To be dependent on the values of the data structure.
** What function do we use to transform elements of a list?                                 :drill:
*** Answer
~map :: (a -> b) -> [a] -> [b]~
** What function do we use to filter elements of a list?                                    :drill:
*** Answer
~filter :: (a -> Bool) -> [a] -> [a]~
** What function can we use to generally "combine" two lists together?                      :drill:
*** Answer
~zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]~
** Implement the function ~reverse~ to reverse a list                                       :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
reverse :: [a] -> [a]
reverse = undefined
#+END_SRC

* Chapter 10
** Sentence                                                                                 :drill:
Folds as a general concept are called <[Catamorphism]>, where <["cata"]>
means "down" and <["morphism"]> means <["transformation"]>

** Implement ~foldr~ for lists                                                              :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
#+END_SRC

** Unroll the evaluation of the following expression                                        :drill:
~foldr (+) 0 [1, 2, 3]~
*** Answer
#+BEGIN_SRC haskell :eval never
foldr (+) 0 [1, 2, 3]
(+) 1 (foldr (+) 0 [2, 3])
(+) 1 ((+) 2 (foldr (+) 0 [3]))
(+) 1 ((+) 2 ((+) 3 (foldr (+) 0 [])))
(+) 1 ((+) 2 ((+) 3 0))
(+) 1 ((+) 2 3)
(+) 1 5
6
#+END_SRC

** Sentence                                                                                 :drill:
Folding happens in two staging <[/Traversing/]> (fold recurses over
the spine) and <[/Folding/]> (fold reduce of the function over the
values)

** Can a ~foldr~ operate on an infinite list? If yes, why and in what cases?                :drill:
*** Answer
Yes, when the function used is not strict on both the arguments.
#+BEGIN_SRC haskell :eval never
foldr (\x b -> f x || b) False xs
#+END_SRC

** Implement ~foldl~ for lists                                                              :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ acc [] = acc
foldl f acc (x:xs) = foldl f (f acc x) xs
#+END_SRC

** Unroll the evaluation of the following expression                                        :drill:
*** Answer
#+BEGIN_EXAMPLE
foldl (+) 0 [1, 2, 3]
foldl (+) ((+) 0 1) [2, 3]
foldl (+) 1 [2, 3]
foldl (+) ((+) 1 2) [3]
foldl (+) 3 [3]
foldl (+) ((+) 3 3) []
foldl (+) 6 []
6
#+END_EXAMPLE

** What kind of fold can be applied to infinite lists? Why?                                 :drill:
*** Answer
~foldr~ because since it's associative to the right the first thing it
does is to execute the function with the first element of the list and
on the rest of the fold, if the function is not strict and doesn't
need the second argument for the result the rest of the fold can be
left not evaluated.
#+BEGIN_EXAMPLE
foldr (||) False (repeat True)
(||) True _ -- don't need to evaluate what's on the right
True
#+END_EXAMPLE

** What kind of fold cannot be applied to infinite lists? Why?                              :drill:
*** Answer
~foldl~ because since it's associative to the left the first thing it
does is to make the recursive function so you have no chance to stop
the computation
#+BEGIN_EXAMPLE
foldl (||) False (repeat True)
foldl (||) ((||) False True) (repeat True)
foldl (||) True (repeat True)
foldl (||) ((||) True True) (repeat True)
foldl (||) True (repeat True)
foldl (||) ((||) True True) (repeat True)
foldl (||) True (repeat True)
foldl (||) ((||) True True) (repeat True)
...
#+END_EXAMPLE
** Implement ~scanr~ for lists                                                              :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr _ z [] = [z]
scanr f z (x:xs) = (f x (head rest)) : rest
  where rest = scanr f z xs
#+END_SRC
** Implement ~scanl~ for lists                                                              :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl _ acc [] = [acc]
scanl f acc (x:xs) = acc : (scanl f (f acc x) xs)
#+END_SRC
** Sentence                                                                                 :drill:
When all /Data Constructors/ in a Datatype don't need values of types
mentioned in the /Type Constructor/, those types are called <[Phantom
Types]> or we say that they <[Have No Witness]>

#+BEGIN_SRC haskell :eval never
data Silly a = Silly
#+END_SRC

* Chapter 11
** The term /Type Constant/ is used to refer to...                                          :drill:
:PROPERTIES:
:ID:       5244b399-cb50-4700-8c84-0eaf065cdc6b
:END:
*** Answer
A type constructor that takes no arguments.
** The term /Data Constant/ is used to refer to...                                          :drill:
:PROPERTIES:
:ID:       45fa0c20-213e-4013-8574-d6302fb4f000
:END:
*** Answer
A data constructor that takes no arguments.
** The term /Type Constructor/ is used to refer to...                                       :drill:
:PROPERTIES:
:ID:       c0e0b4ae-da4d-4a5a-9750-4a919446f4a7
:END:
*** Answer
Denotes a type in a /Data Declaration/
** Give some examples of /Type Constants/                                                   :drill:
:PROPERTIES:
:ID:       aaa4d161-7b09-4ac0-a46c-dc1287083984
:END:
*** Answer
~Bool~, ~Integer~, ~Char~, ~Float~, ~Double~
** Give some examples of /Type Constructors/                                                :drill:
:PROPERTIES:
:ID:       eb94a80b-ac1c-4f48-9cdb-19990f38e1ed
:END:
*** Answer
~Maybe~, ~(,)~, ~[]~, ~Either~

** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       26fadaf0-3926-4871-b352-c0bb7124b232
:END:
We know that /Type Constructor/ is a fully applied, and therefore a
/Concrete Type/ when it is represent as <[~*~]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       2ffb77b4-8d78-42b3-bb4b-1e89fe2525f4
:END:
/Type Constructors/ operate at <[type]> level. Types are resolved at
<[compile-time]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       9e809b96-2c2c-4b49-b415-0d8e9ce6c62b
:END:
/Type Constructors/ are <[functions]> that operate <[type]> level
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       a73cd5b8-658b-4860-b380-a1bf60e27d61
:END:
/Data Constructors/ operate at <[term]> level. Values can be
interacted with at <[run-time]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       809a5248-224a-47db-857a-050a85aaed64
:END:
In a /Datatype Definition/ what comes before the ~=~ is a <[type
constructor]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       2c179350-155b-445c-b587-8f4f998655d9
:END:
In a /Datatype Definition/ what comes after the ~=~ is a <[data
constructor]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       727d8a93-a9f9-4d02-8ca0-5b915f2cc4aa
:END:
The Haskell Report uses the term <[/Type Constant/]> to refer to types
that take no arguments and are already types. In the Report, <[/Type
Constructor/]> is used to refer to types which must have arguments
applied to become a type.
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       904f300b-67f4-45fe-b197-70fc9b2df7ea
:END:
The syntax ~::~ usually means <["has type of"]>
** What are the kinds?                                                                      :drill:
:PROPERTIES:
:ID:       96250e86-196d-4046-be99-130e9938eb34
:VISIBILITY: folded
:END:
*** Answer
Kinds are the types of /Type Constructors/, primarly encoding the
number of arguments they take.

** When kinds become types?                                                                 :drill:
:PROPERTIES:
:ID:       46365b63-8516-4238-be97-542f28f8b75d
:VISIBILITY: folded
:END:
*** Answer
When they are fully applied.

** Kinds application                                                                        :drill:
:PROPERTIES:
:ID:       ad406627-6d4b-43e4-9c52-9767a6d0a8a0
:DRILL_LAST_INTERVAL: 4.6883
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2018-08-19 Sun 18:27]
:VISIBILITY: folded
:END:
How many time the kind ~* -> * -> *~ must be applied to become a type?
*** Answer
2

** What is an Higher-Kinded type?                                                           :drill:
:PROPERTIES:
:ID:       ed1e41cb-de7f-4c23-9931-4e57316b32ad
:VISIBILITY: folded
:END:
*** Answer
A kind that needs to be applied more than once to become a type

** What kind has the following Datatype?                                                    :drill:
:PROPERTIES:
:ID:       2a17521b-99d1-4eff-8317-3aeee32c023d
:VISIBILITY: folded
:END:
#+BEGIN_SRC haskell :eval never
data Silly a b c =
  Silly a b c
  deriving Show
#+END_SRC
*** Answer
~Silly :: * -> * -> * -> *~

** What kind has ~[]~?                                                                      :drill:
:PROPERTIES:
:ID:       48f3ac53-1b89-400b-96c0-32fcf957edcc
:VISIBILITY: folded
:END:
*** Answer
~[] :: * -> *~

** What's the type of ~[]~?                                                                 :drill:
:PROPERTIES:
:ID:       6e33ee49-6583-4085-8319-005556d212cb
:END:
*** Answer
~[] :: [a]~

** What are arguments taken from /Type Constructors/?                                       :drill:
:PROPERTIES:
:ID:       efae5cf1-3e93-46c4-81df-f7a62bcbb67e
:END:
*** Answer
Types

** What are arguments taken from /Data Constructors/?                                       :drill:
:PROPERTIES:
:ID:       c178f70e-9e5d-4d10-8e13-4e60364edc81
:END:
*** Answer
Values

** Naming in patterns                                                                       :drill:
:PROPERTIES:
:ID:       b91b750e-8c4a-4c43-8cfd-79cddff624a2
:DRILL_LAST_INTERVAL: 5.1613
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2018-08-19 Sun 18:27]
:END:
How can you, with a single pattern, match the head, tail and the whole
value of a list like ~_ = [1, 2, 3]~? Also called /As-Pattern/
*** Answer
~l@(h:t) = [1, 2, 3]~

** Ignoring in patterns                                                                     :drill:
:PROPERTIES:
:DRILL_LAST_INTERVAL: 3.6334
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2018-08-19 Sun 18:34]
:ID:       2f11d70a-8a29-4541-95ce-8ed756efa163
:END:
How can you ignore a part of a match in a pattern
*** Answer
With an underscore ~_~. If we are interested only in the tail of a
list we can use a pattern like ~(_:t) = [1, 2, 3]~

** Why should we say, in the /Data Declaration/ below, that ~Price~ depends on ~Integer~?   :drill:
#+BEGIN_SRC haskell :eval never
data Price = Price Integer deriving (Eq, Show)
#+END_SRC
*** Answer
Because you cannot construct ~Price~ values if ~Integer~ is not in the
scope

** Sentence                                                                                 :drill:
A type can be thought as an <[enumeration]> of <[/Data Constructors/]>
that have zero or more arguments.
** Sentence                                                                                 :drill:
Algebraic datatype in Haskell are algebraic because we can describe
the patterns of argument structures using two basic operations:
- sum (ex. ~A | B~)
- product (ex. ~(A, B)~)
** Sentence                                                                                 :drill:
Newtypes
- Only allows a single <[unary]> /Data Constructor/.
- The cardinality is the cardinality of the <[type given as argument]>.
- It only exists at <[compile]> time.
- It has no <[run]> time overhead.
- It uses the same representation of the <[type given as argument]>.
- We can define <[/Typeclasses/]> on it.
** Can you derive /Typeclasses/ on a /Newtype/?                                             :drill:
*** Answer
Yes, with ~GeneralizedNewtypeDeriving~ language extension
** What's the symbol used to define a /Sum Type/?                                           :drill:
*** Answer
~|~ as in ~data Bool = True | False~
** What's the cardinality of a /Sum Type/?                                                  :drill:
*** Answer
The sum of the cardinality of its inhabitants.
** Sentence                                                                                 :drill:
/Product Types/ express <[conjunction]> that is the logic operator
<[and]>.
** Sentence                                                                                 :drill:
/Sum Types/ express <[disjunction]> that is the logic operator <[or]>.
** What's the symbol used to define a /Product Type/?                                       :drill:
*** Answer
There's no special symbol, every /Data Constructor/ with two or more
arguments it's a product.
** What's the cardinality of a /Product Type/?                                              :drill:
*** Answer
The product of the cardinality of its inhabitants.
** Define a /Datatype/ ~Person~ with age and name with record syntax                        :drill:
*** Answer
#+BEGIN_SRC haskell
data Person =
  Person { name :: String
         , age :: String
         }
  deriving (Eq, Show)
#+END_SRC
** What defines implicitly a record syntax?                                                 :drill:
*** Answer
One function for each field called the same as the record.
** When a /Data Declaration/ is in /Normal Form/?                                           :drill:
*** Answer
When we have the /Sum/ of the /Product Types/

#+BEGIN_SRC haskell :results none
:{
data Expression =
    Number Int
  | Add Expression Expression
  | Minus Expression Expression
  | Mul Expression Expression
  | Div Expression Expression
:}
#+END_SRC
** Give an example of accidental bottom in records                                          :drill:
*** Answer
#+BEGIN_SRC haskell
data Car = NotCar | Car {model :: String, year :: String}

model Car {model = "Porche Boxter", year = 2016}
model NotCar
#+END_SRC
** How can the accidental bottom problem can be avoided in records?                         :drill:
*** Answer
By ensuring the completeness of the generated functions for the
records (all the values of that defined type must be records).

#+BEGIN_SRC haskell
data Car = Car {model :: String, year :: Integer}
data Automobile = NotCar | Automobile Car

-- The following will not compile ;-)
-- model NotCar
#+END_SRC
** How can you pattern match a record?                                                      :drill:
*** Answer
By selecting the field and pattern match on the result with a ~case~ expression.



** What's the cardinality of a /Function Type/?                                             :drill:
*** Answer
If the function is ~a -> b~ then the cardinality is ~∥b∥ ^ ∥a∥~
** When a /Kind/ becomes a /Type/?                                                          :drill:
*** Answer
When it's fully applied

* Chapter 12
** What's the definition of ~Maybe~?                                                        :drill:
:PROPERTIES:
:ID:       13dfc99b-44c2-440c-9159-6bbc3dda93b8
:END:
*** Answer
~data Maybe a = Nothing | Just a~

** When should be used ~Maybe~?                                                             :drill:
:PROPERTIES:
:ID:       da6182bc-cde5-49c7-9512-da6bb86c5798
:END:
*** Answer
To encode the effect of failure.

** What's the definition of ~Either~?                                                       :drill:
:PROPERTIES:
:ID:       7f75cf4a-f3da-4526-9f14-22bd8ed28207
:END:
*** Answer
~data Either a b = Left a | Right b~

** When should be used ~Either~?                                                            :drill:
:PROPERTIES:
:ID:       1cb9e4fe-b145-4441-a1e2-e39199cc923a
:END:
*** Answer
To encode the effect of failure when we want more information about
the error

** What do you put on the ~Left~ side of ~Either~?                                          :drill:
:PROPERTIES:
:ID:       1181da3d-cf16-49c4-93fe-1f420e3bc0d6
:END:
*** Answer
The error

** What do you put on the ~Right~ side of ~Either~?                                         :drill:
:PROPERTIES:
:ID:       a25ee471-3ca5-4f20-91fa-ebbb8c96ace6
:END:
*** Answer
The value

** Why the error type is always on the ~Left~ side of ~Either~?                             :drill:
:PROPERTIES:
:ID:       243efcac-3047-432f-9943-0f0e05f7e067
:END:
*** Answer
So that with typeclasses like ~Functor~ that works with a type
constructor with one type parameter we can give it a partially applied
~Either~ with the error part leaving the success part to work with.
** What are the /Kinds/?                                                                    :drill:
:PROPERTIES:
:ID:       6d832698-a7b7-47d5-8a95-27752d5ea5d6
:END:
*** Answer
Kinds are type types of types, or types one level up
** What are /Kinds/ for?                                                                    :drill:
:PROPERTIES:
:ID:       459b9fef-9cb6-47f4-a235-07fbcb3c5ab4
:END:
*** Answer
To generalize behaviour over data with an unknown type
** How do we represent /Kinds/ in Haskell?                                                  :drill:
:PROPERTIES:
:ID:       a2728aaa-f14c-414e-a7db-1631542c77cc
:END:
*** Answer
With the symbol ~*~
** What are the /lifted/ types?                                                             :drill:
:PROPERTIES:
:ID:       e7409301-08f1-4693-8034-ad41c1aa2ad0
:END:
*** Answer
Have kind ~*~, they include every type that can be user defined and
they are every type that can be inhabited by /bottom/ (⊥)
** What are the /unlifted/ types?                                                           :drill:
:PROPERTIES:
:ID:       ac0f8a55-8d29-463e-8fe7-6d09b972bf2f
:END:
*** Anwer
Have kind ~#~, they are types that cannot be inhabited by /bottom/
(⊥) like machine types or raw pointers
** What kind are the /newtypes/? Are they lifted or not? Why?                               :drill:
:PROPERTIES:
:ID:       f1096dbf-d6b3-464e-8bc8-0344f9e4c2ad
:END:
*** Answer
They have kind ~*~ but they are not /lifted/ becase they cannot
contain /bottom/ only they type they contain can contain /bottom/
so they are /unlifted/
** Given the following code                                                                 :drill:
#+BEGIN_SRC haskell :eval never
r :: a -> f a
#+END_SRC

1. What is the kind of ~a~
2. What is the kind of ~f a~
3. What is the kind of ~f~

*** Answer
1. ~*~
2. Since ~(->)~ has kind ~* -> * -> *~ each of applicable types must
   have kind ~*~ so ~f a~ must have kind ~*~
3. Since ~f a~ must have kind ~*~ then ~f~ must have kind ~* -> *~

* Chapter 13
** What's the name of ~<-~ in a ~do~ block?                                                 :drill:
:PROPERTIES:
:ID:       989addc1-0730-4f7d-b5b0-e9d2ee51fb72
:END:
The name is /bind/.
** What's the role of ~<-~ in a ~do~ block?                                                 :drill:
:PROPERTIES:
:ID:       daa048f1-9164-4332-acb5-d07a94fda11f
:END:
Binds a name to the ~𝑎~ of an ~m a~ value, where ~𝑚~ is some monadic structure.
** What's the type of ~return~?                                                             :drill:
:PROPERTIES:
:ID:       0675106d-9839-483f-8bf9-ed88d148f37f
:END:
~Monad m => a -> m a~
** What's the command to create a new simple project name "awesome" with Stack?             :drill:
:PROPERTIES:
:ID:       1f1be699-a613-451a-9c2c-85092e95089b
:END:
~stack new awesome simple~
** What's called ~>>=~?                                                                     :drill:
:PROPERTIES:
:ID:       33841793-1dbd-41b9-99fe-2c7fb1ce704c
:END:
The name is /bind/.
** What's the use of ~>>=~?                                                                 :drill:
:PROPERTIES:
:ID:       c6e4bf89-0cc8-412d-b5f9-62790b93ea26
:END:
It will sequentially compose two actions so that a value generated
from the first will become an argument of the second
** What's a /Module/?                                                                       :drill:
*** Answer
It's a language construct that defines a namespace with a name that
must be the same as the file that contains it. Modules contain the
datatypes, type synonyms, type classes, type class instances and
values.
** What's a /Package/?                                                                      :drill:
*** Answer
A /Package/ it's a collection of modules and its dependencies.
** What's Cabal and what it stands for?                                                     :drill:
*** Answer
It's a package manager and it stands for "Common Architecture for
Building Applications and Libraries"
** What's Stack?                                                                            :drill:
*** Answer
Is a tool for developing Haskell projects based on Cabal and relies on
LTS (Long Term Support) snapshot of packages that are guaranteed to
work together from Stackage.
** What's the command to build a project with ~stack~?                                      :drill:
*** Answer
~stack build~
** What's the command to start a REPL in a project with ~stack~?                            :drill:
*** Answer
~stack ghci~
** What's a /stanza/ in a Cabal file?                                                       :drill:
*** Answer
A section of the configuration, like the following

#+BEGIN_EXAMPLE
executable hello
  hs-source-dirs:   src
  main-is:          Main.hs
  default-language: Haskell2010
  build-depends:    base >= 4.7 && < 5
#+END_EXAMPLE
** In a Module what gets exported by default?                                               :drill:
*** Answer
Every top level bindings.
** How can you export only ~bar~ and ~baz~ from a module ~Foo~?                             :drill:
*** Answer
#+BEGIN_SRC haskell :eval never
module Foo (bar, baz) where

bar = undefined

baz = undefined
#+END_SRC
** What's called the optional list of symbols after a module definition?                    :drill:
*** Answer
It's the /export list/.

#+BEGIN_SRC haskell
module Foo (bar, baz) where

bar = undefined

baz = undefined
#+END_SRC
** In GHCI how do you get a list of the exposed symbols for a module ~Foo~?                 :drill:
*** Answer
~:browse Foo~
** How can you import only ~bar~ and ~baz~ from a module ~Foo~?                             :drill:
*** Answer
~import Foo (bar, baz)~
** What's called the optional list of symbols after a module import?                        :drill:
*** Answer
It's called /import list/
** What's a /qualified import/ of symbols from a module? What's the effect?                 :drill:
*** Answer
~import qualified Foo~

Will import all the symbols in ~Foo~ module preserving the prefix
~Foo~. So if ~Foo~ exports a symbol ~bar~ then to refer to it you need
to use ~Foo.bar~
** How can you customize the prefix for module qualified import?                            :drill:
*** Answer
~import qualified Foo as F~
** How can you import only ~bar~ from ~Foo~ so that ~F.bar~ will work?                      :drill:
*** Answer
~import qualified Foo as F (bar)~
* Chapter 15
** What's an /algebra/?                                                                     :drill:
:PROPERTIES:
:ID:       3ed6014a-2c3d-4ac7-a7e1-ddac69f8c9cf
:END:
*** Answer
- A /set/ of values
- Some /operations/ that operates over those values
- Some /laws/ followed by those operations
** How can be implemented /algebras/ in Haskell                                             :drill:
:PROPERTIES:
:ID:       f1751910-1836-4372-9e87-f7b8bce97556
:END:
*** Answer
Algebras can be implemented with /typeclasses/. The values that
inhabit the /types/ that have an instance of the typeclass are the
/sets/ of values associated to the algebra. The functions defined
in the typeclass are the /operations/ of the algebra.
** What's a Monoid                                                                          :drill:
:PROPERTIES:
:ID:       ca8c6146-5278-4495-b06f-4e73afe9bffe
:END:
*** Answer
An algebra with a binary associative operation and an identity
** What's a Semigroup                                                                       :drill:
:PROPERTIES:
:ID:       acdfd3a5-51cb-4b0e-831d-f95db18a270e
:END:
*** Answer
An algebra with a binary associative operation
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       0d40332d-8b29-4c63-9e76-e01ef01693ef
:END:
Data constructors with only <[nonalphanumeric]> characters that
begins with colon (~:~) are <[infix]> by default
** Definition of Monoid typeclass                                                           :drill:
:PROPERTIES:
:ID:       47c2dcc6-34be-42f4-b87a-831b8ab6525d
:END:
*** Answer
#+BEGIN_SRC haskell
class Monoid a where
  mempty :: a -- identity
  mappend :: a -> a -> a -- associative
  mconcat :: [a] -> a
#+END_SRC
~mconcat~ can be derived
** Derive the implementation of ~mconcat~ given ~mempty~ and ~mappend~                      :drill:
:PROPERTIES:
:ID:       0adfa3a6-4d18-4c36-b966-a8df4838b15b
:END:
*** Answer
#+BEGIN_SRC haskell
mconcat :: [a] -> a
mconcat = foldr mappend mempty
#+END_SRC
** What we mean when we say that some datatype is a monoid?                                 :drill:
:PROPERTIES:
:ID:       3f849830-e34e-4fca-917d-7d965febb3e4
:END:
*** Answer
That it admits a lawful instance of the Monoid typeclass.
** What's the intuitive meaning of the Monoid operation ~mappend~                           :drill:
:PROPERTIES:
:ID:       8393477d-50d2-4d60-86c6-c3ceea6efebb
:END:
*** Answer
Join two values of a type into another value of the same type.
** How does the idenity value ~mempty~ work?                                                :drill:
:PROPERTIES:
:ID:       321b36e9-dd03-4876-a6ac-a1ff5ea90c05
:END:
*** Answer
Using ~mempty~ as a value in ~mappend~ with another value the
result is always the other value.
** Can a type have multiple instances of Monoid?                                            :drill:
:PROPERTIES:
:ID:       41079187-2e72-4b7a-ae6d-f5b07114a58c
:END:
*** Answer
No, every type has one and only one instance of a typeclass
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       d4831771-aa1d-4f60-9021-59d8ea14c784
:END:
Type with instances of ~Num~ form a <[~Monoid~]> under
multiplication and summation.
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       c5aca050-7ffe-4999-a738-9426c5669432
:END:
~List~ form a ~Monoid~ under <[concatenation]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       a2c55761-683b-4304-a943-05acef407370
:END:
~String~ form a ~Monoid~ under <[concatenation]>
** The infix operator ~<>~ is syntactic sugar for                                           :drill:
:PROPERTIES:
:ID:       3c5c0cc5-095c-4423-b332-c0a48cdfd9b7
:END:
*** Answer
~Data.Monoid.mappend~
** How can you give to a type multiple instances of a typeclass?                            :drill:
:PROPERTIES:
:ID:       081f061c-c428-449c-b457-9eae74757533
:END:
*** Answer
By wrapping the type in a newtype.
#+BEGIN_SRC haskell :eval never
import Data.Monoid
Sum 3 <> Sum 2 -- => Sum {getSum=5}
Product 3 <> Product 2 -- => Product {getProduct=6}
#+END_SRC
** State the ~Semigroup~ laws
*** Answer
1. Associativity
   #+BEGIN_SRC haskell :eval never
   (x <> y) <> z = x <> (y <> z)
   #+END_SRC
** State the ~Monoid~ laws                                                                  :drill:
:PROPERTIES:
:ID:       693277e4-b087-4327-985f-869d82fdc75a
:END:
*** Answer
1. Identity
   #+BEGIN_SRC haskell :eval never
   mempty <> x = x <> mempty
   #+END_SRC
2. Associativity
   #+BEGIN_SRC haskell :eval never
   (x <> y) <> z = x <> (y <> z)
   #+END_SRC
** Write the identity property of ~Monoid~                                                  :drill:
:PROPERTIES:
:ID:       a1f36547-f20d-4194-8eed-934c2e58ad53
:END:
*** Answer
#+BEGIN_SRC haskell
monoidIdentityProperty :: Monoid a => a -> Bool
monoidIdentityProperty x = mempty <> x == x && x <> mempty == x
#+END_SRC
** Write the associativity property of ~Monoid~                                             :drill:
:PROPERTIES:
:ID:       8bb1cca2-b2f5-4248-986c-75ad2cbc37a3
:END:
*** Answer
#+BEGIN_SRC haskell
monoidAssociativityProperty :: Monoid a => a -> a -> a -> Bool
monoidAssociativityProperty x y z = (x <> y) <> z == x <> (y <> z)
#+END_SRC
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       deea5030-cb28-420e-8967-64b6f8200910
:END:
- Laws define <[algebras]>.
- Laws provide guardatees and solid foundations.
- Guarantees provide predictable <[composition]> of programs.
- Ability to <[combine]> programs give us the ability to <[reuse]>
  programs in different context.
** What kind of composition will give the newtype ~Sum~ to instances of ~Num~               :drill:
:PROPERTIES:
:ID:       511acebb-f912-415f-9ff7-b9cd33463e74
:END:
*** Answer
Summation.
** What kind of composition will give the newtype ~Product~ to instances of ~Num~           :drill:
:PROPERTIES:
:ID:       afab7789-dc85-4080-a192-5fa3521740aa
:END:
*** Answer
Multiplication.
** What kind of composition will give the newtype ~All~ to boolean values                   :drill:
:PROPERTIES:
:ID:       ce339e44-db11-43df-a9be-d4d83e0de436
:END:
*** Answer
Boolean conjuction aka ~and~ or ~&&~.
** What kind of composition will give the newtype ~Any~ to boolean values                   :drill:
:PROPERTIES:
:ID:       0497bb60-6776-42c3-bc86-02c42614a792
:END:
*** Answer
Boolean disjunction aka ~or~ or ~||~.
** What kind of composition will give the newtype ~First~ to instances of ~Maybe~           :drill:
:PROPERTIES:
:ID:       45da31c1-4726-40ef-a309-0b2e00a01e51
:END:
*** Answer
Keep the first non ~Nothing~ value.
** What kind of composition will give the newtype ~Last~ to instances of ~Maybe~            :drill:
:PROPERTIES:
:ID:       9e5687c1-792e-4c16-8885-d1c26191219d
:END:
*** Answer
Keep the last non ~Nothing~ value.
** What's the definition of /orphan instance/?                                              :drill:
:PROPERTIES:
:ID:       6853a8b1-f44d-469d-9fde-434beb38af64
:END:
*** Answer
Is when an instance of a typeclass is defined for a datatype but
the definition of the typeclass and the definition of the datatype
are not in the same module of the instance.
** What can be done to avoid problems with orphan instances?                                :drill:
:PROPERTIES:
:ID:       ebdf61c2-45f5-4d82-b91c-febf21b7d295
:END:
*** Answer
1. Define types and instances of known typeclasses in the same file.
2. Define typeclasses and their instances for known types in the same file.
3. Wrap known types to define instances of known typeclasses.
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       fb0f9423-96aa-4e65-baf8-3b4cea15ae6b
:END:
An /algebra/ is /stronger/ than another when it provides <[more]>
operations, aka is /stronger/ when we can do more without knowing
the <[specific type]> we are working with.
** Algebras Strength                                                                        :drill:
:PROPERTIES:
:DRILL_CARD_TYPE: hide1cloze
:ID:       e08f5dbc-0448-422a-ba1e-0bb60cfc04aa
:END:
<[/Magma/]> -> <[/Semigroup/]> -> <[/Monoid/]> -> <[/AbelianMonoid/]>
** Exercise                                                                                 :drill:
:PROPERTIES:
:ID:       c5f0e93d-7a3a-4231-8e7f-205763c788de
:END:
Write a instance of ~Semigroup~ for the following type
#+BEGIN_SRC haskell :eval never
data Two a b = Two a b deriving (Eq, Show)
#+END_SRC
*** Answer
#+BEGIN_SRC haskell :eval never
instance (Semigroup a, Semigroup b) => Semigroup (Two a b) where
  mappend (Two x1 y1) (Two x2 y2) = Two (x1 <> x2) (y1 <> y2)
#+END_SRC
** Exercise                                                                                 :drill:
:PROPERTIES:
:ID:       e32d8060-558a-4a71-aaa5-d1f5b4b483c7
:END:
Write a instance of ~Monoid~ for the following type
#+BEGIN_SRC haskell :eval never
data Two a b = Two a b deriving (Eq, Show)
#+END_SRC
*** Answer
#+BEGIN_SRC haskell :eval never
instance (Monoid a, Monoid b) => Monoid (Two a b) where
  mempty = Two mempty mempty
  mappend (Two x1 y1) (Two x2 y2) = Two (x1 <> x2) (y1 <> y2)
#+END_SRC
* Chapter 16
** Sentence                                                                                 :drill:
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       d3daf458-67bc-4916-b7c2-e9f9a1b3984f
:END:
A <[type constant or a fully applied type]> have kind <[~*~]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       2158f567-f960-4796-b8f4-8783c6bc4ad9
:END:
<[Types]> classify <[values]>
** Sentence                                                                                 :drill:
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       266ea23b-47ad-4601-81dc-a942df377475
:END:
<[Kinds]> classify <[types]>
** What kind must have a function argument?                                                 :drill:
:PROPERTIES:
:ID:       36d57755-b1ba-4978-aa3a-3c71c55a7bd5
:END:
*** Answer
Must be a type constant or a fully applied type with kind ~*~
** The ~(<$>)~ is the alias of?                                                             :drill:
:PROPERTIES:
:ID:       b336817f-3e04-420e-bd59-18a5e8afe85e
:END:
*** Answer
~fmap~ of the ~Functor~ typeclass
** State the ~Functor~ laws
*** Answer
1. Identity
   #+BEGIN_SRC haskell :eval never
   fmap id = id
   #+END_SRC
2. Composability
   #+BEGIN_SRC haskell :eval never
   fmap (f . g) == (fmap f) . (fmap g)
   #+END_SRC
** Write the ~Functor~'s identity law                                                       :drill:
:PROPERTIES:
:ID:       3474b7de-32f0-49fc-8593-5c2b4a7d3f23
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
fmap id == id
#+END_SRC
** Write the ~Functor~'s composability law                                                  :drill:
:PROPERTIES:
:ID:       c2ef6b68-2161-414f-a4de-ddd5385cd60e
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
fmap (f . g) == (fmap f) . (fmap g)
#+END_SRC
** What gives us the identity law of ~Functor~?                                             :drill:
:PROPERTIES:
:ID:       beb8ea04-681d-4008-a8a2-59eee64deeee
:END:
*** Answer
The preservation of the functorial structure.
** What gives us the composability law of ~Functor~?                                        :drill:
:PROPERTIES:
:ID:       b8140000-cc69-4fe7-8cd0-ab5e57df7323
:END:
*** Answer
The composability of functions is preserved.
** Question                                                                                 :drill:
SCHEDULED: <2019-05-08 Wed>
:PROPERTIES:
:ID:       72095cde-308f-4b32-976b-3ba5d415076a
:DRILL_LAST_INTERVAL: 3.6614
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-05-04 Sat 10:29]
:END:
Can you write an instance of a typeclass that requires a type with
kind ~* -> *~ for a type with a higher kind? If yes, how?
*** Answer
Yes, by partially applying the type constructor with a concrete
type or with a type variable
** Question                                                                                 :drill:
:PROPERTIES:
:ID:       0ebbe693-ddf4-4440-b8aa-3f9df2bc8262
:END:
Can you write an instance of a typeclass that requires a type with
kind ~* -> *~ for a type with a lower kind? If yes, how?
*** Answer
No
** Exercise                                                                                 :drill:
:PROPERTIES:
:ID:       e184467f-336b-4333-bc0d-d7e83a45c6fe
:END:
Write an instance of ~Functor~ for the following type
#+BEGIN_SRC haskell :eval never
data Two a b = Two a b deriving (Eq, Show)
#+END_SRC

*** Answer
#+BEGIN_SRC haskell :eval never
instance Functor (Two a) where
  fmap f (Two a x) = Two a (f x)
#+END_SRC
** Question                                                                                 :drill:
:PROPERTIES:
:ID:       196eef6a-a61e-4e32-871e-30e85131c203
:END:
1. What's the type of ~fmap show~?
2. What we are doing by partially applying ~fmap~ to a function?
*** Answer
1. ~(Show a, Functor f) => f a -> f String~
2. We are /lifting/ that function, ~show~ in this case, to work
   with all types that admit an instance of ~Functor~
** What's a /natural transformation/?                                                       :drill:
:PROPERTIES:
:ID:       7f259e97-b3a2-495b-a65b-0191b57e0b66
:END:
*** Answer
When you transofrm the /structure/ and leave the /type argument/ alone.
* Chapter 17
** Describe the types of ~$~, ~<>~, ~<$>~, ~<*>~                                            :drill:
:PROPERTIES:
:ID:       cca33d2c-a9a4-4f0c-a771-1143ab3a3ed4
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
 $  ::   (a -> b) ->   a ->   b
<>  ::   a        ->   a ->   a
<$> ::   (a -> b) -> f a -> f b
<*> :: f (a -> b) -> f a -> f b
#+END_SRC
** Why ~Applicative~ is described as monoidal ~Functor~?                                    :drill:
:PROPERTIES:
:ID:       04603444-6fc0-4d86-8e84-4a27438afadc
:END:
*** Answer
Because it needs to combine two piece of functorial structure, one
that wraps the function and one that wraps the value, this
combination can be (or can be seen) as the monoidal ~mappend~.
#+BEGIN_SRC haskell :eval never
--     f ->          f ->   f     -- mappend
--       (a -> b) ->   a ->   b   -- $
<*> :: f (a -> b) -> f a -> f b
#+END_SRC

** State the ~Applicative~ laws                                                             :drill:
:PROPERTIES:
:ID:       6c2f2549-e64b-4623-869c-95832d9fda6f
:END:
*** Answer
1. Identity
   #+BEGIN_SRC haskell :eval never
   pure id <*> v = v
   #+END_SRC
2. Composition
   #+BEGIN_SRC haskell :eval never
   pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
   #+END_SRC
3. Homomorphism
   #+BEGIN_SRC haskell :eval never
   pure f <*> pure x = pure (f x)
   #+END_SRC
4. Interchange
   #+BEGIN_SRC haskell :eval never
   u <*> pure y = pure ($ y) <*> v
   #+END_SRC
** Sentence                                                                                 :drill:
:PROPERTIES:
:ID:       d9ffe903-9f7d-4813-967a-af54eb5d7468
:END:
It is not guaranteed that the <[monoidal]> behaviour of the
applicative instance is the same as the <[monoid]> instance of the
involved type.

** What is the signature of ~Applicative~'s ~pure~ method?                                  :drill:
:PROPERTIES:
:ID:       2dcca1e8-0d68-4f3f-b2d1-736744fec242
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
pure :: a -> f a
pure = undefined
#+END_SRC
** What is the signature of ~Applicative~'s ~apply~ method?                                 :drill:
:PROPERTIES:
:ID:       2000e143-d48d-4dfd-ae25-05069261aabc
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
(<*>) :: f (a -> b) -> f a -> f b
(<*>) = undefined
#+END_SRC
** What is the signature of ~liftA2~? What it does? Write and usage example                 :drill:
:PROPERTIES:
:ID:       c74ff363-df13-4a02-8b78-eaed0c4ae39d
:END:
*** Answer
It let us apply functions with more than one arguments to values
wrapped in functorial structure
#+BEGIN_SRC haskell :eval never
liftA2 :: (a -> b -> c) -> f a -> f b -> f c
liftA2 = undefined

liftA2 (+) (Just 1) (Just 2) == (Just 3)
#+END_SRC
** Implement ~liftA2~ using ~<$>~ and ~<*>~                                                 :drill:
:PROPERTIES:
:ID:       5ab115f8-d1bb-4ffc-a16e-2e5f7470c0c6
:END:
*** Answer
#+BEGIN_SRC haskell
liftA2 :: (a -> b -> c) -> f a -> f b -> f c
liftA2 f fa fb = f <$> fa <*> fb
#+END_SRC
** Exercise                                                                                 :drill:
:PROPERTIES:
:ID:       4b3495a9-bbe9-4a5b-a97f-6e5919041197
:END:
Write an instance of ~Applicative~ for the following type
#+BEGIN_SRC haskell :eval never
data Two a b = Two a b deriving (Eq, Show)
#+END_SRC
*** Answer
#+BEGIN_SRC haskell :eval never
import Data.Monoid

instance Monoid a => Applicative (Two a) where
  pure x = Two mempty x
  (Two x1 f) <*> (Two x2 y) = Two (x1 <> x2) (f y)
#+END_SRC
* Chapter 18
** Write the definition of ~Monad~ typeclass                                                :drill:
:PROPERTIES:
:ID:       cc540456-9a69-4c14-adb6-8e15c390ac8e
:END:
*** Answer
#+BEGIN_SRC haskell :eval never
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
#+END_SRC
** Desugar the following function without using ~do~ notation                               :drill:
:PROPERTIES:
:ID:       7a7345f5-934b-42bd-a40b-6b6e827b129d
:END:
#+BEGIN_SRC haskell :eval never
bindingAndSequencing :: IO ()
bindingAndSequencing = do
  putStrLn "name pls:"
  name <- getLine
  putStrLn ("y helo thar: " ++ name)
#+END_SRC
*** Answer
#+BEGIN_SRC haskell :eval never
bindingAndSequencing :: IO ()
bindingAndSequencing = do
  putStrLn "name pls:" >>
    getLine >>=
      \name ->
        putStrLn $ "Hello: " ++ name
#+END_SRC
** What's the difference between ~(*>)~ and ~(>>)~ operator?                                :drill:
:PROPERTIES:
:ID:       a3176968-ef45-41a9-b1c5-a6875d42bbca
:END:
*** Answer
They are the same the only thing that differs is the constraint,
~(*>)~ works on ~Applicative~, ~(>>)~ works on ~Monad~ (and
therefore on ~Applicative~ too)
#+BEGIN_SRC haskell :eval never
(*>) :: Applicative f => f a -> f b -> f b
(>>) :: Monad m => m a -> m b -> m b
#+END_SRC
** State the ~Monad~ laws                                                                   :drill:
:PROPERTIES:
:ID:       6f1436c6-af2a-4411-ab25-65f101f5fa8d
:END:
*** Answer
1. Left Identity
   #+BEGIN_SRC haskell :eval never
   m >>= return = m
   #+END_SRC
2. Right Identity
   #+BEGIN_SRC haskell :eval never
   return x >>= f = f x
   #+END_SRC
3. Associativity
   #+BEGIN_SRC haskell :eval never
   (m >>= f) >>= g = m >>= (\x -> f x >>= g)
   #+END_SRC
** What's a monadic function?                                                               :drill:
:PROPERTIES:
:ID:       d1567c25-2b91-4108-b745-c9421a9854a3
:END:
*** Answer
A function that returns more structure after being lifted over
monadic structure
** What's the Kleisli operator? What's the signature? What's is good for?                   :drill:
:PROPERTIES:
:ID:       8db4d588-44e2-4cad-a71f-965761f97c4e
:END:
*** Answer
Provides composition for function that return a monadic value
(/monadic function/)
#+BEGIN_SRC haskell
(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c
#+END_SRC
* Chapter 19
* Chapter 20
** Write the definition of ~Foldable~ typeclass
** Write an instance of ~Foldable~ for the following datatype
#+BEGIN_SRC haskell :eval never
data Two a b = Two a b deriving
#+END_SRC
** What's ~Foldable~ for?
*** Answer
"Foldable gives us a way to process values embedded in a structure
as if they existed in a sequential order" or "A class of data
structures that can be folded to a summary value"
** What's the signature of ~foldl~
** What's the signature of ~foldr~
** What's the signature of ~foldMap~
