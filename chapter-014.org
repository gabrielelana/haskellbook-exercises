#+TITLE: Testing

* 14.01 Testing
  Nothing much

* 14.02 A Quick Tour of Testing for the Uninitiated
  - Testing to support the compiler and prevent (still occurring)
    runtime errors.
  - State expectations and verify that the result meets the
    expectations.
  - /Unit Testing/ example driven tests that tests the smallest
    independent units of software. The rerence libray is (/HUnit/)
  - /Specification Testing/ kind of like unit tests but with
    assertions that are more human readable (hence the term
    specification). The reference library is (HSpec)
  - Both /Unit Testing/ and /Specification Testing/ they are not meant
    to tests the interaction between the units.
  - /Property Testing/ you must provide truth-valued, universally
    quantified functions which will be checked on the result of the
    application of the function to a randomly generated input.

* 14.03 Conventional Testing
  Create and empty project [[file:chapter-014/addition/][addition]] and add some /HSpec/ tests

  - /HSpec/ heavily uses /do notation/, /do notation/ allows to
    sequence monadic actions, here the monad is not ~IO~ but a more
    specific ~SpecWith~
  - ~shouldBe :: (Show a, Eq a) => a -> a -> Expectation~
  - ~shouldBe~ is an augmented ~==~

* 14.04 Enter QuickCheck
  Allows to tests for laws or properties of the code. /HSpec/ has
  /QuickCheck/ integration so we can write code as follows

  #+BEGIN_SRC haskell :eval never
  it "x + 1 is alwasy greater than x" $ do
    property $ \x -> x + 1 > (x :: Int)
  #+END_SRC

  /QuickCheck/ relies on a /typeclass/ ~Arbitrary~ to provide a
  generator which is /newtype/ ~Gen~
  #+BEGIN_SRC haskell :eval never
  class Arbitrary a where
    arbitrary :: Gen a
    shrink :: a -> [a]
  #+END_SRC

  We can use ~sample~ to get some random data
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :t sample
  :t sample'
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  sample :: Show a => Gen a -> IO ()
  sample' :: Gen a -> IO [a]
  #+END_EXAMPLE

  We can use ~arbitrary~ to provide a ~Gen a~ for ~sample~
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  sample (arbitrary :: Gen Int)
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  0
  1
  0
  6
  -3
  -1
  -5
  3
  3
  -12
  12
  #+END_EXAMPLE

  We can create a simple generator with the use of ~return~. The
  ~return~ will put our value in a ~Monad~ in this case the ~m~ is
  ~Gen~.
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :t return
  :{
  trivialInt :: Gen Int
  trivialInt = return 1
  :}
  sample' trivialInt
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  return :: Monad m => a -> m a
  [1,1,1,1,1,1,1,1,1,1,1]
  #+END_EXAMPLE

  We can create another kind generator generating values from a
  predefined set of values with ~elements~
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :t elements
  :{
  oneTwoOrThree :: Gen Int
  oneTwoOrThree = elements [1, 2, 3]
  :}
  sample' oneTwoOrThree
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  elements :: [a] -> Gen a
  [1,2,3,2,1,2,3,1,2,3,3]
  #+END_EXAMPLE

  There's also ~choose~ which will choose an element in a tuple of two
  elements.
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :t choose
  :{
  generateBool :: Gen Bool
  generateBool = choose (True, False)
  :}
  sample' generateBool
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  choose :: System.Random.Random a => (a, a) -> Gen a
  [False,False,False,False,True,True,True,True,False,True,False]
  #+END_EXAMPLE

  A more complex example
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :{
  generateTuple :: (Arbitrary a, Arbitrary b) => Gen (a, b)
  generateTuple = do
    a <- arbitrary
    b <- arbitrary
    return (a, b)
  :}
  sample' (generateTuple :: Gen (Int, Int))
  sample' (generateTuple :: Gen (Float, Int))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  [(0,0),(1,-1),(-2,3),(1,5),(-5,5),(3,4),(-10,8),(-12,-6),(-13,-14),(-18,-14),(15,11)]
  [(0.0,0),(-0.4536861,0),(0.9048592,-1),(12.537433,-5),(-0.27819198,-4),(11.777202,-8),(-2.6961212,-5),(-5.017473,-13),(-49.398586,2),(-7.6933117,-3),(-29.489338,10)]
  #+END_EXAMPLE

  We can ask for everything that has an instance of ~Arbitrary~ type
  class. We can also generate ~Maybe~
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck
  :t frequency
  :{
  generateMaybe :: (Arbitrary a) => Gen (Maybe a)
  generateMaybe = do
    a <- arbitrary
    frequency [(1, return Nothing), (3, return (Just a))]
  :}
  sample' (generateMaybe :: (Gen (Maybe Int)))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  frequency :: [(Int, Gen a)] -> Gen a
  [Just 0,Just 2,Just 0,Just 0,Nothing,Just (-7),Nothing,Just 2,Just (-15),Just 0,Just 2]
  #+END_EXAMPLE

* 14.05 Morse Code
  See the implementation [[./chapter-014/morse-code][here]]

  #+BEGIN_SRC bash :results output :wrap EXAMPLE
  cd ./chapter-014/morse-code
  echo "main" | stack ghci -- morse-code:tests
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  GHCi, version 8.4.3: http://www.haskell.org/ghc/  :? for help
  [1 of 1] Compiling Main             ( /home/coder/code/haskellbook-exercises/chapter-014/morse-code/tests/tests.hs, interpreted ) [flags changed]
  Ok, one module loaded.
  Loaded GHCi configuration from /tmp/haskell-stack-ghci/786931a3/ghci-script
  ,*Main> +++ OK, passed 100 tests.
  ,*Main> Leaving GHCi.
  #+END_EXAMPLE

* 14.06 Arbitrary instances
  One of the more important part of learning how to use /QuickCheck/
  is to learn how to write instances of /Arbitrary/ typeclass.

  The simplest instance for the simplest type
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck

  data Trivial = Trivial deriving (Eq, Show)

  :{
  trivialGenerator :: Gen Trivial
  trivialGenerator = return Trivial
  :}

  :{
  instance Arbitrary Trivial where
    arbitrary = trivialGenerator
  :}

  sample' trivialGenerator
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  [Trivial,Trivial,Trivial,Trivial,Trivial,Trivial,Trivial,Trivial,Trivial,Trivial,Trivial]
  #+END_EXAMPLE

  Generating for higher order types, we use the ~Gen~ monad to pluck a
  value of ~a~ out of the air.
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck

  data Identity a = Identity a deriving (Eq, Show)

  :{
  identityGenerator :: Arbitrary a => Gen (Identity a)
  identityGenerator = do
    a <- arbitrary
    return (Identity a)
  :}

  :{
  instance Arbitrary a => Arbitrary (Identity a) where
    arbitrary = identityGenerator
  :}

  :{
  identityGeneratorForInt :: Gen (Identity Int)
  identityGeneratorForInt = identityGenerator
  :}

  putStrLn "=== Identity Int"
  sample identityGeneratorForInt

  putStrLn "=== Identity Char"
  sample (identityGenerator :: Gen (Identity Char))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  === Identity Int
  Identity 0
  Identity 2
  Identity 1
  Identity 0
  Identity (-1)
  Identity (-1)
  Identity (-9)
  Identity 14
  Identity (-1)
  Identity 4
  Identity (-7)
  === Identity Char
  Identity '#'
  Identity 'p'
  Identity '\ESC'
  Identity 'j'
  Identity '\DC2'
  Identity 'S'
  Identity '\US'
  Identity 'f'
  Identity 'X'
  Identity '\a'
  Identity '\a'
  #+END_EXAMPLE

  More interesting is an instance for a sum type. While generating a
  value we need to choose which of the data constructor to use, to do
  that we will use the ~oneof~ function from ~QuickCheck~
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck

  data Sum a b = First a | Second b deriving (Eq, Show)

  :{
  sumGenerator :: (Arbitrary a, Arbitrary b) => Gen (Sum a b)
  sumGenerator = do
    a <- arbitrary
    b <- arbitrary
    oneof [return (First a), return (Second b)]
  :}

  sample (sumGenerator :: Gen (Sum Char Int))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  Second 0
  Second (-1)
  First '/'
  Second 1
  First '\DC4'
  First '\a'
  Second 0
  First '0'
  First 'Z'
  First '\DLE'
  First '\f'
  #+END_EXAMPLE

  We can use ~frequency~ to choose not equally between data
  constructors
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Test.QuickCheck

  data Sum a b = First a | Second b deriving (Eq, Show)

  :{
  sumGenerator :: (Arbitrary a, Arbitrary b) => Gen (Sum a b)
  sumGenerator = do
    a <- arbitrary
    b <- arbitrary
    frequency [(10, return (First a)),
               (1, return (Second b))]
  :}

  sample (sumGenerator :: Gen (Sum Char Int))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  First '\b'
  First '\998494'
  First '9'
  Second 5
  First '\DC2'
  First '\588187'
  First 'L'
  First '\t'
  First '5'
  First 'N'
  First 'E'
  #+END_EXAMPLE

* Exercises

  #+NAME: ghci-clean
  #+BEGIN_SRC emacs-lisp :var content="" :results raw
  (defun report-compiling-module-p (line)
    (string-match-p "\\[[0-9]+ of [0-9]+\\] Compiling" line))

  (defun report-loaded-module-p (line)
    (string-match-p "Ok, .+ modules? loaded\\." line))

  (defun report-eoe-p (line)
    (string-match-p "org-babel-haskell-eoe" line))

  (defun clean-line (line)
    (->> line remove-prompt unquote))

  (defun remove-prompt (line)
    (let ((current-prompt (current-prompt line)))
      (message "current prompt: %S" current-prompt)
      (if (string-empty-p current-prompt)
          line
        (replace-regexp-in-string (concat "\\(?:" current-prompt "[>|] \\)+") "" line))))

  (defun current-prompt (line)
    (if (string-match "\\(^[^|:>]+\\)[|>]" line)
        (match-string 1 line)
      ""))

  (defun unquote (line)
    (replace-regexp-in-string "^\"\\(.*\\)\"$" "\\1" line))

  (string-join
   (seq-map #'clean-line
            (seq-filter
             (lambda (line)
               (and
                (not (string-empty-p line))
                (not (report-eoe-p line))
                (not (report-compiling-module-p line))
                (not (report-loaded-module-p line))))
             (split-string content "\n")))
   "\n")
  #+END_SRC

  #+NAME: add-current-chapter-directory-in-path
  #+BEGIN_SRC emacs-lisp :output raw
  (concat
   ":set -i"
   (file-name-as-directory (file-name-directory (buffer-file-name)))
   (file-name-base (buffer-file-name)))
  #+END_SRC

  #+NAME: add-chapter-directory-in-path
  #+BEGIN_SRC emacs-lisp :var chapter="" :output raw
  (concat
   ":set -i"
   (file-name-as-directory (file-name-directory (buffer-file-name)))
   chapter)
  #+END_SRC

** Validating Numbers into Words
   Write tests for the module [[file:./chapter-008/WordNumber.hs][WordNumber]]

   #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
   <<add-chapter-directory-in-path(chapter="chapter-008")>>
   :load WordNumber

   import Test.Hspec
   import WordNumber (digitToWord, digits, wordNumber)

   :{
   hspec $ do
     describe "digitToWord" $ do
       it "returns zero for 0" $ do
         digitToWord 0 `shouldBe` "zero"
       it "returns one for 1" $ do
         digitToWord 1 `shouldBe` "one"
       it "returns nine for 9" $ do
         digitToWord 9 `shouldBe` "nine"

     describe "digits" $ do
       it "returns [1] for 1" $ do
         digits 1 `shouldBe` [1]
       it "returns [1, 0, 0] for 100" $ do
         digits 100 `shouldBe` [1, 0, 0]
       it "returns [1, 2, 3, 4, 5] for 12345" $ do
         digits 12345 `shouldBe` [1, 2, 3, 4, 5]

     describe "wordNumber" $ do
       it "returns one-zero-zero for 100" $ do
         wordNumber 100 `shouldBe` "one-zero-zero"
       it "returns nien-zero-zero-one for 9001" $ do
         wordNumber 9001 `shouldBe` "nine-zero-zero-one"
   :}
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   digitToWord
     returns zero for 0
     returns one for 1
     returns nine for 9
   digits
     returns [1] for 1
     returns [1, 0, 0] for 100
     returns [1, 2, 3, 4, 5] for 12345
   wordNumber
     returns one-zero-zero for 100
     returns nien-zero-zero-one for 9001
   Finished in 0.0070 seconds
   8 examples, 0 failures
   #+END_EXAMPLE

** Using QuickCheck
   Test some simple mathematical properties with /QuichCheck/

   1. Given the following function
      #+BEGIN_SRC haskell :eval never
      half x = x / 2
      #+END_SRC

      This property should hold
      #+BEGIN_SRC haskell :eval never
      halfIdentity = (*2) . half
      #+END_SRC

      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      half x = x / 2

      :{
      property_HalfIdentity :: Property
      property_HalfIdentity =
        forAll (arbitrary :: Gen (Float)) (\x -> x == (*2) (half x))
      :}

      quickCheckWithResult stdArgs {chatty=False} property_HalfIdentity
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   2. For an ordered list the following property should hold
      #+NAME: ordered-list-property
      #+BEGIN_SRC haskell :eval never
      :{
      listOrdered :: (Ord a) => [a] -> Bool
      listOrdered xs =
        snd $ foldr go (Nothing, True) xs
        where go _ status@(_, False) = status
              go y (Nothing, t) = (Just y, t)
              go y (Just x, t) = (Just y, x >= y)
      :}
      #+END_SRC

      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck
      import Data.List (sort)

      <<ordered-list-property>>

      :{
      orderedListGenerator :: (Arbitrary a, Ord a) => Gen [a]
      orderedListGenerator = do
        a <- arbitrary
        return $ sort a
      :}

      sample' (orderedListGenerator :: Gen [Int])

      :{
      property_OrderedListProperty :: Property
      property_OrderedListProperty =
        forAll orderedListGenerator listOrdered
      :}

      quickCheckWithResult stdArgs {chatty=False} property_OrderedListProperty
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      [[],[],[-3,-2,-1,1],[-3,2,2,2],[],[-8,2,2,5,8,9],[-11,-9,-6,-2,12],[-11,-9,0,5,9,14],[-16,-16,-15,-9,-4,-2,4,5,5,14],[-12,-8,-7,-3,2,16],[-20,-18,-6,17]]
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   3. Test the associative and commutative propertys of addition
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      associativeProperty :: (Eq a, Num a) => a -> a -> a -> Bool
      associativeProperty x y z = (x + y) + z == x + (y + z)
      :}

      :{
      commutativeProperty :: (Eq a, Num a) => a -> a -> Bool
      commutativeProperty x y = x + y == y + x
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary associativeProperty)
      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary commutativeProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   4. Do the same for multiplication
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      associativeProperty :: (Eq a, Num a) => a -> a -> a -> Bool
      associativeProperty x y z = (x * y) * z == x * (y * z)
      :}

      :{
      commutativeProperty :: (Eq a, Num a) => a -> a -> Bool
      commutativeProperty x y = x * y == y * x
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary associativeProperty)
      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary commutativeProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   5. Tests the laws involving ~quot/rem~ and ~div/mod~
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      quotAndRemLaw :: Integral a => a -> a -> Bool
      quotAndRemLaw x y = (quot x y) * y + (rem x y) == x
      :}

      :{
      divAndModLaw :: Integral a => a -> a -> Bool
      divAndModLaw x y = (div x y) * y + (mod x y) == x
      :}


      quickCheckWithResult (stdArgs {chatty=False}) (forAll (arbitrary :: Gen (Int, NonZero Int)) (\(x, NonZero y) -> quotAndRemLaw x y))
      quickCheckWithResult (stdArgs {chatty=False}) (forAll (arbitrary :: Gen (Int, NonZero Int)) (\(x, NonZero y) -> divAndModLaw x y))
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   6. Is ~(^)~ associative? Is it commutative? Try to prove it
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      associativeProperty :: (Integral a) => a -> a -> a -> Bool
      associativeProperty x y z = (x ^ y) ^ z == x ^ (y ^ z)
      :}

      :{
      commutativeProperty :: (Integral a) => a -> a -> Bool
      commutativeProperty x y = x ^ y == y ^ x
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary associativeProperty)
      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary commutativeProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Failure {numTests = 1, numShrinks = 0, numShrinkTries = 0, numShrinkFinal = 0, usedSeed = TFGenR 00000012355EF74100000000000F4240000000000000E3F3000000F807829600 0 16777216 25 0, usedSize = 0, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 1 test): \n0\n0\n0\n", failingTestCase = ["0","0","0"]}
      Failure {numTests = 2, numShrinks = 1, numShrinkTries = 0, numShrinkFinal = 1, usedSeed = TFGenR 00000012355EF74100000000000F4240000000000000E3F3000000F807829600 0 100663296 27 0, usedSize = 1, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 2 tests and 1 shrink): \n0\n1\n", failingTestCase = ["0","1"]}
      #+END_EXAMPLE

   7. Test that reversing the reverse of a list is equal to identity
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      reverseOfReverseProperty :: (Eq a) => [a] -> Bool
      reverseOfReverseProperty xs = (reverse . reverse) xs == xs
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary reverseOfReverseProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   8. Write a property for the definition of ~($)~
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      applicationOperatorDefinition :: (Eq b) => Blind (a -> b) -> a -> Bool
      applicationOperatorDefinition (Blind f) x = (f x) == (f $ x)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary applicationOperatorDefinition)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

      Write a property for the definition of ~(.)~
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      composeOperatorDefinition :: (Eq c, Eq b) => Blind (a -> b) -> Blind (b -> c) -> a -> Bool
      composeOperatorDefinition (Blind g) (Blind f) x = ((f . g) x) == (f (g x))
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary composeOperatorDefinition)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

      Alternatively we can create a generator for the function
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck

      :{
      applicationOperatorDefinition :: (Eq b) => Blind (a -> b) -> a -> Bool
      applicationOperatorDefinition (Blind f) x = (f x) == (f $ x)
      :}

      :{
      functionGenerator :: (Arbitrary b) => Gen (Blind (a -> b))
      functionGenerator = do
        b <- arbitrary
        return $ Blind (\_ -> b)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll functionGenerator applicationOperatorDefinition)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

      NB: ~Blind~ is a /type-level modifier/ to modify the behaviour
      of the generators, we need to tell /QuickCheck/ that we don't
      need to be in the ~Show~ class, this is needed here because
      functions (what we want to generate) cannot be in the ~Show~
      class

   9. See if the following functions are equal
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      -- ? foldr (:) == (++)

      import Test.QuickCheck

      :{
      equalityProperty :: (Eq a) => [a] -> [a] -> Bool
      equalityProperty xs ys = (xs ++ ys) == (foldr (:) xs ys)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary equalityProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      -- ? foldr (++) [] == concat

      import Test.QuickCheck

      :{
      equalityProperty :: (Foldable t, Eq a) => t [a] -> Bool
      equalityProperty xs = (concat xs) == (foldr (++) [] xs)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary equalityProperty)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   10. Is that so?
       #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
       -- ? f n xs = length (take n xs) == n

       :{
       property :: NonNegative Int -> [a] -> Bool
       property (NonNegative n) xs = length (take n xs) == n
       :}

       quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary property)
       #+END_SRC

       #+RESULTS:
       #+BEGIN_EXAMPLE
       Failure {numTests = 1, numShrinks = 0, numShrinkTries = 0, numShrinkFinal = 0, usedSeed = TFGenR 00000012355EF74100000000000F4240000000000000E3F3000000F807829600 0 17179869184 35 0, usedSize = 0, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 1 test): \nNonNegative {getNonNegative = 1}\n[]\n", failingTestCase = ["NonNegative {getNonNegative = 1}","[]"]}
       #+END_EXAMPLE

       It is not true when the length of the original list is less than ~n~

   11. Test if the composition between ~read~ and ~show~ works
       #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
       -- ? (read . show) x == x

       :{
       property :: (Eq a, Show a, Read a) => a -> Bool
       property x = (read . show) x == x
       :}

       quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary property)
       #+END_SRC

       #+RESULTS:
       #+BEGIN_EXAMPLE
       Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
       #+END_EXAMPLE

** Failure
   Find out why for the following function
   #+BEGIN_SRC haskell :eval never
   square x = x * x
   #+END_SRC

   The following property does not hold
   #+BEGIN_SRC haskell :eval never
   squareIdentity x = (square . sqrt) x == x
   #+END_SRC

   #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
   import Test.QuickCheck

   :{
   square :: (Num a) => a -> a
   square x = x * x
   :}

   :{
   squareIdentity :: (Eq a, Floating a) => NonNegative a -> Bool
   squareIdentity (NonNegative x) = (square . sqrt) x == x
   :}

   :{
   squareIdentity' :: (Ord a, Floating a) => NonNegative a -> Bool
   squareIdentity' (NonNegative x) = abs (((square . sqrt) x) - x) <= 0.00001
   :}

   quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary squareIdentity)
   quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary squareIdentity')
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Failure {numTests = 1, numShrinks = 0, numShrinkTries = 0, numShrinkFinal = 0, usedSeed = TFGenR 00000012355EF74100000000000F4240000000000000E3F3000000F807829600 0 144115188075855872 58 0, usedSize = 0, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 1 test): \nNonNegative {getNonNegative = 0.4602144408586566}\n", failingTestCase = ["NonNegative {getNonNegative = 0.4602144408586566}"]}
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   #+END_EXAMPLE

   Because of the floating point representation you cannot compare
   directly for equality you need to compare with a tolerance

** Idempotence
   Use /QuickCheck/ to demonstrate idempotence for the following
   functions

   #+NAME: idempotency-functions
   #+BEGIN_SRC haskell :eval never
   :{
   twice :: (a -> a) -> a -> a
   twice f = f . f
   :}

   :{
   fourTimes :: (a -> a) -> a -> a
   fourTimes = twice . twice
   :}
   #+END_SRC

   1. Using the following function
      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck
      import Data.Char (toUpper)

      <<idempotency-functions>>

      :{
      capitalizeWord :: String -> String
      capitalizeWord "" = ""
      capitalizeWord (c:s) = (toUpper c) : s
      :}

      :{
      property :: String -> Bool
      property s =
        (capitalizeWord s == twice capitalizeWord s)
        &&
        (capitalizeWord s == fourTimes capitalizeWord s)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary property)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   2. Using the following function
      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      import Test.QuickCheck
      import Data.List (sort)

      <<idempotency-functions>>

      :{
      property :: (Ord a) => [a] -> Bool
      property xs =
        (sort xs == twice sort xs)
        &&
        (sort xs == fourTimes sort xs)
      :}

      quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary property)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

** Make Generators for Datatypes

   1. Equal probability for each
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      data Fool = Fulse | Frue deriving (Eq, Show)

      :{
      instance Arbitrary Fool where
        arbitrary = elements [Fulse, Frue]
      :}

      sample' (arbitrary :: Gen Fool)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      [Fulse,Fulse,Fulse,Fulse,Frue,Fulse,Fulse,Fulse,Frue,Fulse,Frue]
      #+END_EXAMPLE

   2. With 2/3s chance of ~Fulse~, 1/3 chance of ~Frue~.
      #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      data Fool = Fulse | Frue deriving (Eq, Show)

      :{
      instance Arbitrary Fool where
        arbitrary = frequency [(2, return Fulse), (1, return Frue)]
      :}

      sample' (arbitrary :: Gen Fool)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      [Frue,Fulse,Frue,Fulse,Fulse,Fulse,Frue,Fulse,Fulse,Frue,Fulse]
      #+END_EXAMPLE

** Hangman Testing

   1. Test the function ~fillInCharacters~
      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      <<add-chapter-directory-in-path(chapter="chapter-013/hangman/src")>>
      :l Main

      import Test.Hspec

      :{
      hspec $ do
        describe "fillInCharacter" $ do
          it "should fill character when in word to guess" $ do
            let puzzle = Puzzle "foo" [Nothing, Nothing, Nothing] []
            let puzzleAfter = Puzzle "foo" [Nothing, Just 'o', Just 'o'] ['o']
            fillInCharacter puzzle 'o' `shouldBe` puzzleAfter

          it "should not fill character when not in word to guess" $ do
            let puzzle = Puzzle "foo" [Nothing, Nothing, Nothing] []
            let puzzleAfter = Puzzle "foo" [Nothing, Nothing, Nothing] ['h']
            fillInCharacter puzzle 'h' `shouldBe` puzzleAfter
      :}
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      fillInCharacter
        should fill character when in word to guess
        should not fill character when not in word to guess
      Finished in 0.0005 seconds
      2 examples, 0 failures
      #+END_EXAMPLE

      A property testing alternative
      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      <<add-chapter-directory-in-path(chapter="chapter-013/hangman/src")>>

      :l Main
      import Data.Maybe (catMaybes)
      import Test.QuickCheck

      :{
      wordsGenerator :: Gen String
      wordsGenerator =
        (arbitrary :: Gen String) `suchThat` (\s -> (length $ words s) > 0)
      :}

      :{
      wordGenerator :: Gen String
      wordGenerator = do
        s <- wordsGenerator
        return $ (head . words) s
      :}

      :{
      hangmanPuzzleGenerator :: Gen Puzzle
      hangmanPuzzleGenerator = do
        wordToGuess <- wordGenerator
        return $ createPuzzle wordToGuess
      :}

      :{
      monotoneCheck :: Puzzle -> Puzzle -> Bool
      monotoneCheck (Puzzle _ discoveredBefore guessedBefore) (Puzzle _ discoveredAfter guessedAfter) =
        (length guessedBefore <= length guessedAfter) &&
        (length (catMaybes discoveredBefore) <= length (catMaybes discoveredAfter))
      :}

      :{
      fillInCharaterIsMonotone :: Property
      fillInCharaterIsMonotone = forAll hangmanPuzzleGenerator
        (\p -> forAll (arbitrary :: Gen Char)
          (\c -> monotoneCheck p (fillInCharacter p c)))
      :}

      quickCheckWithResult (stdArgs {chatty=False}) fillInCharaterIsMonotone
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
      #+END_EXAMPLE

   2. Test the function ~handleGuess~ (unfortunately we have messages
      printed on the stdout, maybe I will learn later how to remove
      that...)
      #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
      <<add-chapter-directory-in-path(chapter="chapter-013/hangman/src")>>
      :l Main

      import Test.Hspec

      :{
      hspec $ do
        describe "handleGuess" $ do
          it "should fill charater when in word to guess" $ do
            let puzzle = Puzzle "foo" [Nothing, Nothing, Nothing] []
            let expected = Puzzle "foo" [Nothing, Just 'o', Just 'o'] ['o']
            result <- handleGuess puzzle 'o'
            result `shouldBe` expected

          it "should not fill charater when not in word to guess" $ do
            let puzzle = Puzzle "foo" [Nothing, Nothing, Nothing] []
            let expected = Puzzle "foo" [Nothing, Nothing, Nothing] ['h']
            result <- handleGuess puzzle 'h'
            result `shouldBe` expected

          it "should not record a guess if already guessed" $ do
            let puzzle = Puzzle "foo" [Nothing, Nothing, Nothing] ['h']
            let expected = Puzzle "foo" [Nothing, Nothing, Nothing] ['h']
            result <- handleGuess puzzle 'h'
            result `shouldBe` expected
      :}
      #+END_SRC

      #+RESULTS:
      #+BEGIN_EXAMPLE
      handleGuess
      Your guess was: o
      You guessed right!
        should fill charater when in word to guess
      Your guess was: h
      You guessed wrong! Try again ;-)
        should not fill charater when not in word to guess
      Your guess was: h
      You already guessed that character, pick something else...
        should not record a guess if already guessed
      Finished in 0.0017 seconds
      3 examples, 0 failures
      #+END_EXAMPLE

** Validating Ciphers
   #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
   <<add-chapter-directory-in-path(chapter="chapter-011")>>

   :l Cipher
   import Test.QuickCheck

   alphabet = "abcdefghjkilmnopqrstuvwxyz"

   :{
   wordGenerator :: Gen String
   wordGenerator = do
     n <- elements [4..10]
     vectorOf n (elements alphabet)
   :}

   :{
   shiftGenerator :: Gen Int
   shiftGenerator = elements [0..(length alphabet - 1)]
   :}

   :{
   caesarRoundTrip :: Int -> String -> Bool
   caesarRoundTrip n s = (caesarDecode alphabet n . caesarEncode alphabet n) s == s
   :}

   :{
   vigenereRoundTrip :: String -> String -> Bool
   vigenereRoundTrip k s = (vigenereDecode alphabet k . vigenereEncode alphabet k) s == s
   :}

   :{
   quickCheckWithResult (stdArgs {chatty=False})
     (forAll shiftGenerator
       (\n -> forAll wordGenerator
         (\w -> caesarRoundTrip n w)))
   :}

   :{
   quickCheckWithResult (stdArgs {chatty=False})
     (forAll wordGenerator
       (\keyword -> forAll wordGenerator
         (\word -> vigenereRoundTrip keyword word)))
   :}
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   #+END_EXAMPLE
