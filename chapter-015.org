#+TITLE: Monoid, Semigroup

* 15.01 Monoids and Semigropus
  Haskell community recognized abstract patterns in code which have
  well-defined lawful representation in mathematics. Those
  abstractions are called /Algebras/

* 15.02 What we talk about when we talk about algebras
  /Algebra/
  - Branch of mathematics that study symbols and the rules governing
    their manipulation. Don't care about specific values but the rules
    of how how to manipulate symbols representing those values.
  - Refers to some /operations/ and a /set/ they operate over.
  - In Haskell algebras can be implemented with /typeclasses/. The
    /set/ is the /type/ the operation are for. The /operations/ are
    specified in the /typeclass/. The instance of the /typeclass/
    defines how each operation will perform for a given /type/ or
    /set/.

* 15.03 Monoid
  One of the algebras we use is /monoid/. A /monoid/ is a binary
  associative operation with an identity.

  A monoid is a function that takes two arguments and follows two
  laws: associativity and identity.
  - associativity: the arguments can be regrouped in different orders
    and give the same result.
  - identity: exists a value that used with another value in the
    binary operation the result is always the other value.

  When we say something /is a monoid/ or can be described as monoidal,
  we mean you can define at least one law-abiding Monoid instance for
  it.

* 15.04 How Monoid is defined in Haskell
  The typeclass abstracts and generalizes the pattern so that you
  write code in terms of any type that can be monoidally combined.
  The monoidal operation is an operation tha intuitively lets you
  "join" things together. This operation in Haskell is called
  ~mappend~

  #+BEGIN_SRC haskell :results output :wrap EXAMPLE :epilogue ":load"
  :i Monoid
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  class Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
    {-# MINIMAL mempty, mappend #-}
          -- Defined in ‘GHC.Base’
  instance Monoid [a] -- Defined in ‘GHC.Base’
  instance Monoid Ordering -- Defined in ‘GHC.Base’
  instance Monoid a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
  instance Monoid a => Monoid (IO a) -- Defined in ‘GHC.Base’
  instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
  instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
           Monoid (a, b, c, d, e)
    -- Defined in ‘GHC.Base’
  instance (Monoid a, Monoid b, Monoid c, Monoid d) =>
           Monoid (a, b, c, d)
    -- Defined in ‘GHC.Base’
  instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
    -- Defined in ‘GHC.Base’
  instance (Monoid a, Monoid b) => Monoid (a, b)
    -- Defined in ‘GHC.Base’
  instance Monoid () -- Defined in ‘GHC.Base’
  #+END_EXAMPLE

  - ~mappend~ is how /any/ two values that inhabits a type that
    implements ~Monoid~ can be joined together.
  - ~mempty~ is the identity value of that type for the ~mappend~
    operation.

* 15.05 Examples of using Monoid

  Monoid for List (~mappend~ is implemented with ~++~ and ~mempty~ is ~[]~)
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  mappend [1, 2, 3] [4, 5, 6]
  mappend "gabriele" "lana"
  mconcat [[1], [2, 3], [4]]
  mappend [1..10] mempty
  mappend mempty [1..10]
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  [1,2,3,4,5,6]
  gabrielelana
  [1,2,3,4]
  [1,2,3,4,5,6,7,8,9,10]
  [1,2,3,4,5,6,7,8,9,10]
  #+END_EXAMPLE

* 15.06 Why Integer doesn't have an instance of Monoid
  Because it will not be possible to choose between two monoidal
  operations ~*~ and ~+~. To avoid the conflic, to avoid the use of
  scoping tricks and to abide by the rule that typeclass instances are
  unique to the types they are for, Haskell uses the /newtype/
  ~Product~ and ~Sum~ defined in ~Data.Monoid~ to disambiguate.

  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid

  mappend (1::Integer) (2::Integer)
  mappend (Product 1) (Product 2)
  mappend (Sum 1) (Sum 2)
  mappend (Sum 1.7) (Sum 2.3)
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE

  <interactive>:3290:1: error:
      • No instance for (Monoid Integer) arising from a use of ‘mappend’
      • In the expression: mappend (1 :: Integer) (2 :: Integer)
        In an equation for ‘it’: it = mappend (1 :: Integer) (2 :: Integer)
  Product {getProduct = 2}
  Sum {getSum = 3}
  Sum {getSum = 4.0}
  #+END_EXAMPLE

  We say that:
  - Types with instances of ~Num~ form a ~Monoid~ under /multiplication/
    and /summation/
  - Lists form a ~Monoid~ under /concatenation/

  Multiple types have multiple possible monoids, we usually enforce
  the unique instance rule of /typeclasses/ with /newtypes/

  Why newtypes?
  - To signal intent: make it clear that the only thing you intend to
    do is to wrap the underlying type. The /newtype/ cannot grow into
    a more complicated type while /datatype/ can.
  - To improve type safety: to avoid mixing up many values that have
    the same representation but they are used for different things and
    with different meaning.
  - To add different typeclasses to a type without changing its
    representation (like with ~Data.Monoid.Product~ and
    ~Data.Monid.Sum~).

  For ~mappend~ we can use the infix operator ~<>~ as syntactic sugar
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  :t (Data.Monoid.<>)
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  (Data.Monoid.<>) :: Monoid m => m -> m -> m
  #+END_EXAMPLE

  A few examples
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid

  [1, 2, 3] <> [4, 5, 6]
  (Sum 4) <> (Sum 5)
  (Sum 4) <> (Sum 5) <> (Sum 2)
  (Product 4) <> (Product 5) <> (Product 2)
  getSum $ (Sum 4) <> (Sum 5) <> (Sum 2)
  getProduct $ (Product 4) <> (Product 5) <> (Product 2)
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  [1,2,3,4,5,6]
  Sum {getSum = 9}
  Sum {getSum = 11}
  Product {getProduct = 40}
  11
  40
  #+END_EXAMPLE

* 15.07 Why Bother?
  - Having principled laws for it means we can compose monoidal operations safely.
  - A common use of monoids is to structure and describe common modes of processing data

* 15.08 Laws
  Laws describes what constitutes a valid instance of an /algebra/, if
  an instance is /lawful/ then all the property derived from those
  laws then apply also to that instance, then we can have programs
  that compose well and with predictable behaviours.

  - Laws define algebras
  - Laws provide guarantees (solid foundations)
  - Guarantees provide predictable composition of programs
  - Ability to combine programs gives us the ability to reuse programs
    in different contexts

  Laws of /Monoid/

  #+BEGIN_SRC haskell :results silent :epilogue ":load" :post ghci-clean(content=*this*)
  -- left identity
  left_identity_property x = mappend mempty x == x

  -- right identity
  right_identity_property x = mappend x mempty == x

  -- associativity
  associativity_property x y z = (mappend x (mappend y z)) == (mappend (mappend x y) z)

  -- with this we can derive concat
  derive_concat_property x = (mconcat x) == (foldr mappend mempty x)
  #+END_SRC

  The important part is that we have those guarantees even if we don't
  know what Monoid we are working with :smile:

* 15.09 Different Instance, Same Representation
  Multiple types have multiple instances of the Monoid typeclass, to
  differentiate we will use newtypes like for numbers with ~Prod~ and ~Sum~

  Booleans have a monoid for conjunction (~and~ with ~All~) and
  disjuntion (~and~ with ~Any~)
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid

  All True <> All True
  All True <> All False
  All False <> All True
  All False <> All False

  Any True <> Any True
  Any True <> Any False
  Any False <> Any True
  Any False <> Any False
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  All {getAll = True}
  All {getAll = False}
  All {getAll = False}
  All {getAll = False}
  Any {getAny = True}
  Any {getAny = True}
  Any {getAny = True}
  Any {getAny = False}
  #+END_EXAMPLE

  ~Maybe~ have multiple instances of Monoid, the newtype ~First~ will
  select the typeclass that will keep the leftmost non ~Nothing~
  value.
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid

  First (Just 1) <> First (Just 2)
  First Nothing <> First (Just 2)
  First (Just 1) <> First Nothing

  Last (Just 1) <> Last (Just 2)
  Last Nothing <> Last (Just 2)
  Last (Just 1) <> Last Nothing
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  First {getFirst = Just 1}
  First {getFirst = Just 2}
  First {getFirst = Just 1}
  Last {getLast = Just 2}
  Last {getLast = Just 2}
  Last {getLast = Just 1}
  #+END_EXAMPLE

* 15.10 Reusing Algebras by Asking for Algebras
  We can use instances of Monoid for certain types to create instances
  of Monoid for larger types made of those types
  #+BEGIN_SRC haskell :eval never
  instance (Monoid a, Monoid b) => Monoid (a, b)
  #+END_SRC

  The Monoid constraint on smaller types for larger types made of
  those smaller types is needed when the monoidal composistion of the
  larger type involves the monoidal composition of the smaller types.

** Exercise: Optional Monoid
   Write the ~Monoid~ instance of ~Optional~ defined below
   #+NAME: optional-definition
   #+BEGIN_SRC haskell :eval never
   data Optional a = Nada | Only a deriving (Eq, Show)
   #+END_SRC

   Expected behaviour
   #+BEGIN_SRC haskell :eval never
   Prelude> Only (Sum 1) <> Only (Sum 1)
   Only (Sun {getSum = 2})

   Prelude> Only (Product 4) <> Only (Product 2)
   Only (Product {getProduct = 8})

   Prelude> Only (Sum 1) <> Nada
   Only (Sum {getSum = 1})

   Prelude> Only [1] <> Nada
   Only [1]

   Prelude> Nada <> Only (Sum 1)
   Only (Sum {getSum = 1})
   #+END_SRC

   Implementation
   #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
   import Data.Monoid

   <<optional-definition>>

   :{
   instance Monoid a => Monoid (Optional a) where
     mempty = Nada

     mappend Nada y = y
     mappend x Nada = x
     mappend (Only x) (Only y) = Only (mappend x y)
   :}

   Only (Sum 1) <> Only (Sum 1)
   Only (Product 4) <> Only (Product 2)
   Only (Sum 1) <> Nada
   Only [1] <> Nada
   Nada <> Only (Sum 1)
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Only (Sum {getSum = 2})
   Only (Product {getProduct = 8})
   Only (Sum {getSum = 1})
   Only [1]
   Only (Sum {getSum = 1})
   #+END_EXAMPLE

** Orphan Instances
   An orphan instance is when an instance of a typeclass is defined
   for a datatype but the definition of the typeclass and the
   definition of the datatype are not in the same module of the
   instance (FC). If you don't "own" the datatype or the typeclass then
   newtype the datatype (FC).

   To avoid problems: (FC)
   1. Define types and instances of typeclasses in the same file.
   2. Define typeclasses and their instances for known types in the
      same file.
   3. Wrap known types to define instances of known typeclasses.

* 15.11 Madness
  The idea of /mad libs/ is to take a template of a phrase and blindly
  substitue categories of words and see if the result is funny

  #+BEGIN_EXAMPLE
  {exclamation}! he said {adverb} as he jumped
  into his car {noun} and drove off with his
  {adjective} wife.
  #+END_EXAMPLE

  #+BEGIN_SRC haskell :results silent
  import Data.Monoid

  type Exclamation = String
  type Verb = String
  type Adjective = String
  type Adverb = String
  type Noun = String

  :{
  madlibbin :: Exclamation -> Adverb -> Noun -> Adjective -> String
  madlibbin e adv n adj =
    e <> "! he said " <> adv <> " as he jumped into his car " <>
    n <> " and drove off with his " <> adj <> " wife."
  :}

  -- Rewrite the code using mconcat

  :{
  madlibbin' :: Exclamation -> Adverb -> Noun -> Adjective -> String
  madlibbin' e adv n adj = mconcat [
    e,
    "! he said ",
    adv,
    " as he jumped into his car ",
    n,
    " and drove off with his ",
    adj,
    " wife."]
  :}
  #+END_SRC

* 15.12 Better Living Through QuickCheck

  Testing associativity
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid
  import Test.QuickCheck

  :{
  monoidAssociativityProperty :: (Eq m, Monoid m) => m -> m -> m -> Bool
  monoidAssociativityProperty x y z = x <> (y <> z) == (x <> y) <> z
  :}

  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary monoidAssociativityProperty)
  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary (monoidAssociativityProperty :: String -> String -> String -> Bool))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  #+END_EXAMPLE

  Testing left and right identity
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.Monoid
  import Test.QuickCheck

  :{
  monoidLeftIdentityProperty :: (Eq m, Monoid m) => m -> Bool
  monoidLeftIdentityProperty x = mempty <> x == x
  :}

  :{
  monoidRightIdentityProperty :: (Eq m, Monoid m) => m -> Bool
  monoidRightIdentityProperty x = x <> mempty == x
  :}

  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary monoidLeftIdentityProperty)
  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary monoidRightIdentityProperty)

  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary (monoidLeftIdentityProperty :: String -> Bool))
  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary (monoidRightIdentityProperty :: String -> Bool))

  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary (monoidLeftIdentityProperty :: All -> Bool))
  quickCheckWithResult (stdArgs {chatty=False}) (forAll arbitrary (monoidRightIdentityProperty :: Any -> Bool))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  #+END_EXAMPLE

  Catching an invalid ~Monoid~ instance
  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Control.Monad
  import Test.QuickCheck
  import Data.Monoid

  data Bull = Fools | Twoo deriving (Eq, Show)

  :{
  instance Arbitrary Bull where
    arbitrary = elements [Fools, Twoo]
  :}

  -- We need to demonstrate that this is not a valid instance of Monoid
  :{
  instance Monoid Bull where
    mempty = Fools
    mappend _ _ = Fools
  :}

  :{
  monoidAssociativity :: Bull -> Bull -> Bull -> Bool
  monoidAssociativity x y z = x <> (y <> z) == (x <> y) <> z
  :}

  :{
  monoidLeftIdentity :: Bull -> Bool
  monoidLeftIdentity x = mempty <> x == x
  :}

  :{
  monoidRightIdentity :: Bull -> Bool
  monoidRightIdentity x = x <> mempty == x
  :}

  :{
  main :: IO ()
  main = do
    quickCheckWithResult (stdArgs {chatty=False}) (monoidAssociativity :: Bull -> Bull -> Bull -> Bool) >>= print
    quickCheckWithResult (stdArgs {chatty=False}) (monoidLeftIdentity :: Bull -> Bool) >>= print
    quickCheckWithResult (stdArgs {chatty=False}) (monoidRightIdentity :: Bull -> Bool) >>= print
  :}

  main
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
  Failure {numTests = 2, numShrinks = 0, numShrinkTries = 0, numShrinkFinal = 0, usedSeed = TFGenR 70B5C0277FEE812BD445B897F1E4FE4136D5DA2011DCFB46F2C5E50F73B2F9DA 0 6291456 23 0, usedSize = 1, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 2 tests): \nTwoo\n", failingTestCase = ["Twoo"]}
  Failure {numTests = 2, numShrinks = 0, numShrinkTries = 0, numShrinkFinal = 0, usedSeed = TFGenR 70B5C0277FEE812BD445B897F1E4FE4136D5DA2011DCFB46F2C5E50F73B2F9DA 0 12582912 24 0, usedSize = 1, reason = "Falsifiable", theException = Nothing, labels = [], output = "*** Failed! Falsifiable (after 2 tests): \nTwoo\n", failingTestCase = ["Twoo"]}
  #+END_EXAMPLE

** Exercise: Maybe Another Monoid
   Write a ~Monoid~ instance for ~Optional~ type which respects the
   following expectations and which is lawful.

   #+BEGIN_EXAMPLE
   Prelude> First' (Only 1) <> First' Nada
   First' {getFirst = Only 1}

   Prelude> First' Nada <> First' Nada
   First' {getFirst = Nada}

   Prelude> First' Nada <> First' (Only 2)
   First' {getFirst = Only 2}

   Prelude> First' (Only 1) <> First' (Only 2)
   First' {getFirst = Only 1}
   #+END_EXAMPLE

   #+BEGIN_SRC haskell :results replace output :noweb yes :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
   import Data.Monoid
   import Test.QuickCheck

   <<optional-definition>>

   newtype First' a = First' {getFirst :: Optional a} deriving (Eq, Show)

   :{
   instance Monoid (First' a) where
     mempty = First' {getFirst = Nada}

     -- mappend x@(First' {getFirst = Nada}) y@(First' {getFirst = Nada}) = x
     -- mappend x@(First' {getFirst = (Only _)}) y@(First' {getFirst = Nada}) = x
     -- mappend x@(First' {getFirst = Nada}) y@(First' {getFirst = (Only _)}) = y
     -- mappend x@(First' {getFirst = (Only _)}) y@(First' {getFirst = (Only _)}) = x

     mappend x@(First' {getFirst = (Only _)}) _ = x
     mappend (First' {getFirst = Nada}) y = y
   :}

   :{
   instance Arbitrary a => Arbitrary (First' a) where
     arbitrary = do
       x <- arbitrary
       elements [First' {getFirst = Only x}, First' {getFirst = Nada}]
   :}

   :{
   monoidAssociativity :: (Eq m, Monoid m) => m -> m -> m -> Bool
   monoidAssociativity x y z = x <> (y <> z) == (x <> y) <> z
   :}

   :{
   monoidLeftIdentity :: (Eq m, Monoid m) => m -> Bool
   monoidLeftIdentity x = mempty <> x == x
   :}

   :{
   monoidRightIdentity :: (Eq m, Monoid m) => m -> Bool
   monoidRightIdentity x = x <> mempty == x
   :}

   :{
   main :: IO ()
   main = do
     quickCheckWithResult (stdArgs {chatty=False}) (monoidAssociativity :: First' String -> First' String -> First' String -> Bool) >>= print
     quickCheckWithResult (stdArgs {chatty=False}) (monoidLeftIdentity :: First' String -> Bool) >>= print
     quickCheckWithResult (stdArgs {chatty=False}) (monoidRightIdentity :: First' String -> Bool) >>= print
   :}

   main
   #+END_SRC

   #+RESULTS:
   #+BEGIN_EXAMPLE
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
   #+END_EXAMPLE

* 15.13 Semigroup
  The definition of ~Semigroup~ is the following (FC) aka a binary
  associative operation. A ~Monoid~ is also a ~Semigroup~
  #+BEGIN_SRC haskell :eval never
  class Semigroup where
    (<>) :: a -> a -> a
  #+END_SRC

  A useful type that is ~Semigroup~ but not a ~Monoid~ is ~NotEmpty~
  #+BEGIN_SRC haskell :eval never
  data NonEmpty = a :| [a] deriving (Eq, Ord, Show)
  #+END_SRC

  Here ~:|~ is an infix data constructor that takes two arguments,
  data constructors with only nonalphanumeric characters that begins
  with ~:~ is infix by default

  #+BEGIN_SRC haskell :results replace output :wrap EXAMPLE :epilogue ":load" :post ghci-clean(content=*this*)
  import Data.List.NonEmpty as N
  import Data.Semigroup as S

  1 :| [2, 3, 4]
  :t 1 :| [2, 3, 4]
  :t (<>)
  xs = 1 :| [2, 3]
  ys = 4 :| [5, 6]
  xs <> ys
  #+END_SRC

  #+RESULTS:
  #+BEGIN_EXAMPLE
  1 :| [2,3,4]
  1 :| [2, 3, 4] :: Num a => NonEmpty a
  (<>) :: Semigroup a => a -> a -> a
  1 :| [2,3,4,5,6]
  #+END_EXAMPLE

* 15.14 Strength can be Weakness
  An /algebra/ is /stronger/ than another when it provides more
  operations aka it is stronger when you can do more without knowing
  the specific type you are working with. (FC)

  Not always stronger is better because there are useful datatypes
  that cannot satisfy certain laws.

  Strength: /Magma/ -> /Semigroup/ -> /Monoid/ -> /AbelianMonoid/ (FC)

* Exercises

  #+NAME: ghci-clean
  #+BEGIN_SRC emacs-lisp :var content="" :results raw
  (defun report-compiling-module-p (line)
    (string-match-p "\\[[0-9]+ of [0-9]+\\] Compiling" line))

  (defun report-loaded-module-p (line)
    (string-match-p "Ok, .+ modules? loaded\\." line))

  (defun report-eoe-p (line)
    (string-match-p "org-babel-haskell-eoe" line))

  (defun clean-line (line)
    (->> line remove-prompt unquote))

  (defun remove-prompt (line)
    (let ((current-prompt (current-prompt line)))
      (message "current prompt: %S" current-prompt)
      (if (string-empty-p current-prompt)
          line
        (replace-regexp-in-string (concat "\\(?:" current-prompt "[>|] \\)+") "" line))))

  (defun current-prompt (line)
    (if (string-match "\\(^[^|:>]+\\)[|>]" line)
        (match-string 1 line)
      ""))

  (defun unquote (line)
    (replace-regexp-in-string "^\"\\(.*\\)\"$" "\\1" line))

  (string-join
   (seq-map #'clean-line
            (seq-filter
             (lambda (line)
               (and
                (not (string-empty-p line))
                (not (report-eoe-p line))
                (not (report-compiling-module-p line))
                (not (report-loaded-module-p line))))
             (split-string content "\n")))
   "\n")
  #+END_SRC

  #+NAME: add-current-chapter-directory-in-path
  #+BEGIN_SRC emacs-lisp :output raw
  (concat
   ":set -i"
   (file-name-as-directory (file-name-directory (buffer-file-name)))
   (file-name-base (buffer-file-name)))
  #+END_SRC

  #+NAME: add-chapter-directory-in-path
  #+BEGIN_SRC emacs-lisp :var chapter="" :output raw
  (concat
   ":set -i"
   (file-name-as-directory (file-name-directory (buffer-file-name)))
   chapter)
  #+END_SRC
